TypeInfoFactory { public static TypeInfoArray getTypeInfoForArray(Type type) { Preconditions.checkArgument(TypeUtils.isArray(type)); return new TypeInfoArray(type); } private TypeInfoFactory(); static TypeInfoArray getTypeInfoForArray(Type type); static TypeInfo getTypeInfoForField(Field f, Type typeDefiningF); }
TypeInfoFactory { public static TypeInfo getTypeInfoForField(Field f, Type typeDefiningF) { Class<?> classDefiningF = TypeUtils.toRawClass(typeDefiningF); Type type = f.getGenericType(); Type actualType = getActualType(type, typeDefiningF, classDefiningF); return new TypeInfo(actualType); } private TypeInfoFactory(); static TypeInfoArray getTypeInfoForArray(Type type); static TypeInfo getTypeInfoForField(Field f, Type typeDefiningF); }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings("unchecked") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return "Factory[type=" + boxed.getName() + "+" + unboxed.getName() + ",adapter=" + typeAdapter + "]"; } }; } private TypeAdapters(); static TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter); @SuppressWarnings("rawtypes") static final TypeAdapter<Class> CLASS; static final TypeAdapterFactory CLASS_FACTORY; static final TypeAdapter<BitSet> BIT_SET; static final TypeAdapterFactory BIT_SET_FACTORY; static final TypeAdapter<Boolean> BOOLEAN; static final TypeAdapter<Boolean> BOOLEAN_AS_STRING; static final TypeAdapterFactory BOOLEAN_FACTORY; static final TypeAdapter<Number> BYTE; static final TypeAdapterFactory BYTE_FACTORY; static final TypeAdapter<Number> SHORT; static final TypeAdapterFactory SHORT_FACTORY; static final TypeAdapter<Number> INTEGER; static final TypeAdapterFactory INTEGER_FACTORY; static final TypeAdapter<Number> LONG; static final TypeAdapter<Number> FLOAT; static final TypeAdapter<Number> DOUBLE; static final TypeAdapter<Number> NUMBER; static final TypeAdapterFactory NUMBER_FACTORY; static final TypeAdapter<Character> CHARACTER; static final TypeAdapterFactory CHARACTER_FACTORY; static final TypeAdapter<String> STRING; static final TypeAdapter<BigDecimal> BIG_DECIMAL; static final TypeAdapter<BigInteger> BIG_INTEGER; static final TypeAdapterFactory STRING_FACTORY; static final TypeAdapter<StringBuilder> STRING_BUILDER; static final TypeAdapterFactory STRING_BUILDER_FACTORY; static final TypeAdapter<StringBuffer> STRING_BUFFER; static final TypeAdapterFactory STRING_BUFFER_FACTORY; static final TypeAdapter<URL> URL; static final TypeAdapterFactory URL_FACTORY; static final TypeAdapter<URI> URI; static final TypeAdapterFactory URI_FACTORY; static final TypeAdapter<InetAddress> INET_ADDRESS; static final TypeAdapterFactory INET_ADDRESS_FACTORY; static final TypeAdapter<UUID> UUID; static final TypeAdapterFactory UUID_FACTORY; static final TypeAdapterFactory TIMESTAMP_FACTORY; static final TypeAdapter<Calendar> CALENDAR; static final TypeAdapterFactory CALENDAR_FACTORY; static final TypeAdapter<Locale> LOCALE; static final TypeAdapterFactory LOCALE_FACTORY; static final TypeAdapter<JsonElement> JSON_ELEMENT; static final TypeAdapterFactory JSON_ELEMENT_FACTORY; static final TypeAdapterFactory ENUM_FACTORY; }
TypeAdapters { public static <T1> TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings("unchecked") public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) { final Class<? super T2> requestedType = typeToken.getRawType(); if (!clazz.isAssignableFrom(requestedType)) { return null; } return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException("Expected a " + requestedType.getName() + " but was " + result.getClass().getName()); } return result; } }; } @Override public String toString() { return "Factory[typeHierarchy=" + clazz.getName() + ",adapter=" + typeAdapter + "]"; } }; } private TypeAdapters(); static TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter); @SuppressWarnings("rawtypes") static final TypeAdapter<Class> CLASS; static final TypeAdapterFactory CLASS_FACTORY; static final TypeAdapter<BitSet> BIT_SET; static final TypeAdapterFactory BIT_SET_FACTORY; static final TypeAdapter<Boolean> BOOLEAN; static final TypeAdapter<Boolean> BOOLEAN_AS_STRING; static final TypeAdapterFactory BOOLEAN_FACTORY; static final TypeAdapter<Number> BYTE; static final TypeAdapterFactory BYTE_FACTORY; static final TypeAdapter<Number> SHORT; static final TypeAdapterFactory SHORT_FACTORY; static final TypeAdapter<Number> INTEGER; static final TypeAdapterFactory INTEGER_FACTORY; static final TypeAdapter<Number> LONG; static final TypeAdapter<Number> FLOAT; static final TypeAdapter<Number> DOUBLE; static final TypeAdapter<Number> NUMBER; static final TypeAdapterFactory NUMBER_FACTORY; static final TypeAdapter<Character> CHARACTER; static final TypeAdapterFactory CHARACTER_FACTORY; static final TypeAdapter<String> STRING; static final TypeAdapter<BigDecimal> BIG_DECIMAL; static final TypeAdapter<BigInteger> BIG_INTEGER; static final TypeAdapterFactory STRING_FACTORY; static final TypeAdapter<StringBuilder> STRING_BUILDER; static final TypeAdapterFactory STRING_BUILDER_FACTORY; static final TypeAdapter<StringBuffer> STRING_BUFFER; static final TypeAdapterFactory STRING_BUFFER_FACTORY; static final TypeAdapter<URL> URL; static final TypeAdapterFactory URL_FACTORY; static final TypeAdapter<URI> URI; static final TypeAdapterFactory URI_FACTORY; static final TypeAdapter<InetAddress> INET_ADDRESS; static final TypeAdapterFactory INET_ADDRESS_FACTORY; static final TypeAdapter<UUID> UUID; static final TypeAdapterFactory UUID_FACTORY; static final TypeAdapterFactory TIMESTAMP_FACTORY; static final TypeAdapter<Calendar> CALENDAR; static final TypeAdapterFactory CALENDAR_FACTORY; static final TypeAdapter<Locale> LOCALE; static final TypeAdapterFactory LOCALE_FACTORY; static final TypeAdapter<JsonElement> JSON_ELEMENT; static final TypeAdapterFactory JSON_ELEMENT_FACTORY; static final TypeAdapterFactory ENUM_FACTORY; }
TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings("unchecked") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null; } }; } private TypeAdapters(); static TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter); @SuppressWarnings("rawtypes") static final TypeAdapter<Class> CLASS; static final TypeAdapterFactory CLASS_FACTORY; static final TypeAdapter<BitSet> BIT_SET; static final TypeAdapterFactory BIT_SET_FACTORY; static final TypeAdapter<Boolean> BOOLEAN; static final TypeAdapter<Boolean> BOOLEAN_AS_STRING; static final TypeAdapterFactory BOOLEAN_FACTORY; static final TypeAdapter<Number> BYTE; static final TypeAdapterFactory BYTE_FACTORY; static final TypeAdapter<Number> SHORT; static final TypeAdapterFactory SHORT_FACTORY; static final TypeAdapter<Number> INTEGER; static final TypeAdapterFactory INTEGER_FACTORY; static final TypeAdapter<Number> LONG; static final TypeAdapter<Number> FLOAT; static final TypeAdapter<Number> DOUBLE; static final TypeAdapter<Number> NUMBER; static final TypeAdapterFactory NUMBER_FACTORY; static final TypeAdapter<Character> CHARACTER; static final TypeAdapterFactory CHARACTER_FACTORY; static final TypeAdapter<String> STRING; static final TypeAdapter<BigDecimal> BIG_DECIMAL; static final TypeAdapter<BigInteger> BIG_INTEGER; static final TypeAdapterFactory STRING_FACTORY; static final TypeAdapter<StringBuilder> STRING_BUILDER; static final TypeAdapterFactory STRING_BUILDER_FACTORY; static final TypeAdapter<StringBuffer> STRING_BUFFER; static final TypeAdapterFactory STRING_BUFFER_FACTORY; static final TypeAdapter<URL> URL; static final TypeAdapterFactory URL_FACTORY; static final TypeAdapter<URI> URI; static final TypeAdapterFactory URI_FACTORY; static final TypeAdapter<InetAddress> INET_ADDRESS; static final TypeAdapterFactory INET_ADDRESS_FACTORY; static final TypeAdapter<UUID> UUID; static final TypeAdapterFactory UUID_FACTORY; static final TypeAdapterFactory TIMESTAMP_FACTORY; static final TypeAdapter<Calendar> CALENDAR; static final TypeAdapterFactory CALENDAR_FACTORY; static final TypeAdapter<Locale> LOCALE; static final TypeAdapterFactory LOCALE_FACTORY; static final TypeAdapter<JsonElement> JSON_ELEMENT; static final TypeAdapterFactory JSON_ELEMENT_FACTORY; static final TypeAdapterFactory ENUM_FACTORY; }
TypeAdapters { public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings("unchecked") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return "Factory[type=" + base.getName() + "+" + sub.getName() + ",adapter=" + typeAdapter + "]"; } }; } private TypeAdapters(); static TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter); @SuppressWarnings("rawtypes") static final TypeAdapter<Class> CLASS; static final TypeAdapterFactory CLASS_FACTORY; static final TypeAdapter<BitSet> BIT_SET; static final TypeAdapterFactory BIT_SET_FACTORY; static final TypeAdapter<Boolean> BOOLEAN; static final TypeAdapter<Boolean> BOOLEAN_AS_STRING; static final TypeAdapterFactory BOOLEAN_FACTORY; static final TypeAdapter<Number> BYTE; static final TypeAdapterFactory BYTE_FACTORY; static final TypeAdapter<Number> SHORT; static final TypeAdapterFactory SHORT_FACTORY; static final TypeAdapter<Number> INTEGER; static final TypeAdapterFactory INTEGER_FACTORY; static final TypeAdapter<Number> LONG; static final TypeAdapter<Number> FLOAT; static final TypeAdapter<Number> DOUBLE; static final TypeAdapter<Number> NUMBER; static final TypeAdapterFactory NUMBER_FACTORY; static final TypeAdapter<Character> CHARACTER; static final TypeAdapterFactory CHARACTER_FACTORY; static final TypeAdapter<String> STRING; static final TypeAdapter<BigDecimal> BIG_DECIMAL; static final TypeAdapter<BigInteger> BIG_INTEGER; static final TypeAdapterFactory STRING_FACTORY; static final TypeAdapter<StringBuilder> STRING_BUILDER; static final TypeAdapterFactory STRING_BUILDER_FACTORY; static final TypeAdapter<StringBuffer> STRING_BUFFER; static final TypeAdapterFactory STRING_BUFFER_FACTORY; static final TypeAdapter<URL> URL; static final TypeAdapterFactory URL_FACTORY; static final TypeAdapter<URI> URI; static final TypeAdapterFactory URI_FACTORY; static final TypeAdapter<InetAddress> INET_ADDRESS; static final TypeAdapterFactory INET_ADDRESS_FACTORY; static final TypeAdapter<UUID> UUID; static final TypeAdapterFactory UUID_FACTORY; static final TypeAdapterFactory TIMESTAMP_FACTORY; static final TypeAdapter<Calendar> CALENDAR; static final TypeAdapterFactory CALENDAR_FACTORY; static final TypeAdapter<Locale> LOCALE; static final TypeAdapterFactory LOCALE_FACTORY; static final TypeAdapter<JsonElement> JSON_ELEMENT; static final TypeAdapterFactory JSON_ELEMENT_FACTORY; static final TypeAdapterFactory ENUM_FACTORY; }
TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings("unchecked") public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return "Factory[type=" + type.getName() + ",adapter=" + typeAdapter + "]"; } }; } private TypeAdapters(); static TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter); @SuppressWarnings("rawtypes") static final TypeAdapter<Class> CLASS; static final TypeAdapterFactory CLASS_FACTORY; static final TypeAdapter<BitSet> BIT_SET; static final TypeAdapterFactory BIT_SET_FACTORY; static final TypeAdapter<Boolean> BOOLEAN; static final TypeAdapter<Boolean> BOOLEAN_AS_STRING; static final TypeAdapterFactory BOOLEAN_FACTORY; static final TypeAdapter<Number> BYTE; static final TypeAdapterFactory BYTE_FACTORY; static final TypeAdapter<Number> SHORT; static final TypeAdapterFactory SHORT_FACTORY; static final TypeAdapter<Number> INTEGER; static final TypeAdapterFactory INTEGER_FACTORY; static final TypeAdapter<Number> LONG; static final TypeAdapter<Number> FLOAT; static final TypeAdapter<Number> DOUBLE; static final TypeAdapter<Number> NUMBER; static final TypeAdapterFactory NUMBER_FACTORY; static final TypeAdapter<Character> CHARACTER; static final TypeAdapterFactory CHARACTER_FACTORY; static final TypeAdapter<String> STRING; static final TypeAdapter<BigDecimal> BIG_DECIMAL; static final TypeAdapter<BigInteger> BIG_INTEGER; static final TypeAdapterFactory STRING_FACTORY; static final TypeAdapter<StringBuilder> STRING_BUILDER; static final TypeAdapterFactory STRING_BUILDER_FACTORY; static final TypeAdapter<StringBuffer> STRING_BUFFER; static final TypeAdapterFactory STRING_BUFFER_FACTORY; static final TypeAdapter<URL> URL; static final TypeAdapterFactory URL_FACTORY; static final TypeAdapter<URI> URI; static final TypeAdapterFactory URI_FACTORY; static final TypeAdapter<InetAddress> INET_ADDRESS; static final TypeAdapterFactory INET_ADDRESS_FACTORY; static final TypeAdapter<UUID> UUID; static final TypeAdapterFactory UUID_FACTORY; static final TypeAdapterFactory TIMESTAMP_FACTORY; static final TypeAdapter<Calendar> CALENDAR; static final TypeAdapterFactory CALENDAR_FACTORY; static final TypeAdapter<Locale> LOCALE; static final TypeAdapterFactory LOCALE_FACTORY; static final TypeAdapter<JsonElement> JSON_ELEMENT; static final TypeAdapterFactory JSON_ELEMENT_FACTORY; static final TypeAdapterFactory ENUM_FACTORY; }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ConstructorConstructor { public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) { final Type type = typeToken.getType(); final Class<? super T> rawType = typeToken.getRawType(); @SuppressWarnings("unchecked") final InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type); if (typeCreator != null) { return new ObjectConstructor<T>() { @Override public T construct() { return typeCreator.createInstance(type); } }; } @SuppressWarnings("unchecked") final InstanceCreator<T> rawTypeCreator = (InstanceCreator<T>) instanceCreators.get(rawType); if (rawTypeCreator != null) { return new ObjectConstructor<T>() { @Override public T construct() { return rawTypeCreator.createInstance(type); } }; } ObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType); if (defaultConstructor != null) { return defaultConstructor; } ObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType); if (defaultImplementation != null) { return defaultImplementation; } return newUnsafeAllocator(type, rawType); } ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators); ObjectConstructor<T> get(TypeToken<T> typeToken); @Override String toString(); }
ConstructorConstructor { @Override public String toString() { return instanceCreators.toString(); } ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators); ObjectConstructor<T> get(TypeToken<T> typeToken); @Override String toString(); }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
JsonWriter implements Closeable, Flushable { public boolean isLenient() { return lenient; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter value(long value) throws IOException { writeDeferredName(); beforeValue(); out.write(Long.toString(value)); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter beginObject() throws IOException { writeDeferredName(); return open(EMPTY_OBJECT, "{"); } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter value(double value) throws IOException { if (Double.isNaN(value) || Double.isInfinite(value)) { throw new IllegalArgumentException("Numeric values must be finite, but was " + value); } writeDeferredName(); beforeValue(); out.append(Double.toString(value)); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter jsonValue(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.append(value); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public final void setIndent(String indent) { if (indent.length() == 0) { this.indent = null; this.separator = ":"; } else { this.indent = indent; this.separator = ": "; } } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public void close() throws IOException { out.close(); int size = stackSize; if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) { throw new IOException("Incomplete document"); } stackSize = 0; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public final boolean isHtmlSafe() { return htmlSafe; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter name(String name) throws IOException { if (name == null) { throw new NullPointerException("name == null"); } if (deferredName != null) { throw new IllegalStateException(); } if (stackSize == 0) { throw new IllegalStateException("JsonWriter is closed."); } deferredName = name; return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public void flush() throws IOException { if (stackSize == 0) { throw new IllegalStateException("JsonWriter is closed."); } out.flush(); } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter endArray() throws IOException { return close(EMPTY_ARRAY, NONEMPTY_ARRAY, "]"); } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter beginArray() throws IOException { writeDeferredName(); return open(EMPTY_ARRAY, "["); } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public final void setLenient(boolean lenient) { this.lenient = lenient; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter endObject() throws IOException { return close(EMPTY_OBJECT, NONEMPTY_OBJECT, "}"); } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public final void setSerializeNulls(boolean serializeNulls) { this.serializeNulls = serializeNulls; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public final void setHtmlSafe(boolean htmlSafe) { this.htmlSafe = htmlSafe; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); string(value); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public final boolean getSerializeNulls() { return serializeNulls; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter value(boolean value) throws IOException { writeDeferredName(); beforeValue(); out.write(value ? "true" : "false"); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter value(Number value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); String string = value.toString(); if (!lenient && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) { throw new IllegalArgumentException("Numeric values must be finite, but was " + value); } beforeValue(); out.append(string); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter nullValue() throws IOException { if (deferredName != null) { if (serializeNulls) { writeDeferredName(); } else { deferredName = null; return this; } } beforeValue(); out.write("null"); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
JsonReader implements Closeable { public void endObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_OBJECT) { stackSize--; pathNames[stackSize] = null; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException("Expected END_OBJECT but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { @Override public String toString() { return getClass().getSimpleName() + " at line " + getLineNumber() + " column " + getColumnNumber(); } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public boolean nextBoolean() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_TRUE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return true; } else if (p == PEEKED_FALSE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return false; } throw new IllegalStateException("Expected a boolean but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public double nextDouble() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return (double) peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"'); } else if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else if (p != PEEKED_BUFFERED) { throw new IllegalStateException("Expected a double but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peeked = PEEKED_BUFFERED; double result = Double.parseDouble(peekedString); if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { throw new MalformedJsonException("JSON forbids NaN and infinities: " + result + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public String nextString() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED) { result = nextQuotedValue('"'); } else if (p == PEEKED_BUFFERED) { result = peekedString; peekedString = null; } else if (p == PEEKED_LONG) { result = Long.toString(peekedLong); } else if (p == PEEKED_NUMBER) { result = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else { throw new IllegalStateException("Expected a string but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public String nextName() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED_NAME) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED_NAME) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED_NAME) { result = nextQuotedValue('"'); } else { throw new IllegalStateException("Expected a name but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peeked = PEEKED_NONE; pathNames[stackSize - 1] = result; return result; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public boolean hasNext() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public void nextNull() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_NULL) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; } else { throw new IllegalStateException("Expected null but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public String getPath() { StringBuilder result = new StringBuilder().append('$'); for (int i = 0, size = stackSize; i < size; i++) { switch (stack[i]) { case JsonScope.EMPTY_ARRAY: case JsonScope.NONEMPTY_ARRAY: result.append('[').append(pathIndices[i]).append(']'); break; case JsonScope.EMPTY_OBJECT: case JsonScope.DANGLING_NAME: case JsonScope.NONEMPTY_OBJECT: result.append('.'); if (pathNames[i] != null) { result.append(pathNames[i]); } break; case JsonScope.NONEMPTY_DOCUMENT: case JsonScope.EMPTY_DOCUMENT: case JsonScope.CLOSED: break; } } return result.toString(); } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public void skipValue() throws IOException { int count = 0; do { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); count++; } else if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); count++; } else if (p == PEEKED_END_ARRAY) { stackSize--; count--; } else if (p == PEEKED_END_OBJECT) { stackSize--; count--; } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) { skipUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) { skipQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) { skipQuotedValue('"'); } else if (p == PEEKED_NUMBER) { pos += peekedNumberLength; } peeked = PEEKED_NONE; } while (count != 0); pathIndices[stackSize - 1]++; pathNames[stackSize - 1] = "null"; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public void beginArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); pathIndices[stackSize - 1] = 0; peeked = PEEKED_NONE; } else { throw new IllegalStateException("Expected BEGIN_ARRAY but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public void beginObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); peeked = PEEKED_NONE; } else { throw new IllegalStateException("Expected BEGIN_OBJECT but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public final void setLenient(boolean lenient) { this.lenient = lenient; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public void endArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_ARRAY) { stackSize--; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException("Expected END_ARRAY but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public JsonToken peek() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } switch (p) { case PEEKED_BEGIN_OBJECT: return JsonToken.BEGIN_OBJECT; case PEEKED_END_OBJECT: return JsonToken.END_OBJECT; case PEEKED_BEGIN_ARRAY: return JsonToken.BEGIN_ARRAY; case PEEKED_END_ARRAY: return JsonToken.END_ARRAY; case PEEKED_SINGLE_QUOTED_NAME: case PEEKED_DOUBLE_QUOTED_NAME: case PEEKED_UNQUOTED_NAME: return JsonToken.NAME; case PEEKED_TRUE: case PEEKED_FALSE: return JsonToken.BOOLEAN; case PEEKED_NULL: return JsonToken.NULL; case PEEKED_SINGLE_QUOTED: case PEEKED_DOUBLE_QUOTED: case PEEKED_UNQUOTED: case PEEKED_BUFFERED: return JsonToken.STRING; case PEEKED_LONG: case PEEKED_NUMBER: return JsonToken.NUMBER; case PEEKED_EOF: return JsonToken.END_DOCUMENT; default: throw new AssertionError(); } } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public long nextLong() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"'); try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException("Expected a long but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); long result = (long) asDouble; if (result != asDouble) { throw new NumberFormatException("Expected a long but was " + peekedString + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public void close() throws IOException { peeked = PEEKED_NONE; stack[0] = JsonScope.CLOSED; stackSize = 1; in.close(); } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public final boolean isLenient() { return lenient; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public int nextInt() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } int result; if (p == PEEKED_LONG) { result = (int) peekedLong; if (peekedLong != result) { throw new NumberFormatException("Expected an int but was " + peekedLong + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"'); try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException("Expected an int but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); result = (int) asDouble; if (result != asDouble) { throw new NumberFormatException("Expected an int but was " + peekedString + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ISO8601Utils { public static String format(Date date, boolean millis, TimeZone tz) { Calendar calendar = new GregorianCalendar(tz, Locale.US); calendar.setTime(date); int capacity = "yyyy-MM-ddThh:mm:ss".length(); capacity += millis ? ".sss".length() : 0; capacity += tz.getRawOffset() == 0 ? "Z".length() : "+hh:mm".length(); StringBuilder formatted = new StringBuilder(capacity); padInt(formatted, calendar.get(Calendar.YEAR), "yyyy".length()); formatted.append('-'); padInt(formatted, calendar.get(Calendar.MONTH) + 1, "MM".length()); formatted.append('-'); padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), "dd".length()); formatted.append('T'); padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), "hh".length()); formatted.append(':'); padInt(formatted, calendar.get(Calendar.MINUTE), "mm".length()); formatted.append(':'); padInt(formatted, calendar.get(Calendar.SECOND), "ss".length()); if (millis) { formatted.append('.'); padInt(formatted, calendar.get(Calendar.MILLISECOND), "sss".length()); } int offset = tz.getOffset(calendar.getTimeInMillis()); if (offset != 0) { int hours = Math.abs((offset / (60 * 1000)) / 60); int minutes = Math.abs((offset / (60 * 1000)) % 60); formatted.append(offset < 0 ? '-' : '+'); padInt(formatted, hours, "hh".length()); formatted.append(':'); padInt(formatted, minutes, "mm".length()); } else { formatted.append('Z'); } return formatted.toString(); } static String format(Date date); static String format(Date date, boolean millis); static String format(Date date, boolean millis, TimeZone tz); static Date parse(String date, ParsePosition pos); }
ISO8601Utils { public static String format(Date date) { return format(date, false, TIMEZONE_UTC); } static String format(Date date); static String format(Date date, boolean millis); static String format(Date date, boolean millis, TimeZone tz); static Date parse(String date, ParsePosition pos); }
ISO8601Utils { public static Date parse(String date, ParsePosition pos) throws ParseException { Exception fail = null; try { int offset = pos.getIndex(); int year = parseInt(date, offset, offset += 4); if (checkOffset(date, offset, '-')) { offset += 1; } int month = parseInt(date, offset, offset += 2); if (checkOffset(date, offset, '-')) { offset += 1; } int day = parseInt(date, offset, offset += 2); int hour = 0; int minutes = 0; int seconds = 0; int milliseconds = 0; boolean hasT = checkOffset(date, offset, 'T'); if (!hasT && (date.length() <= offset)) { Calendar calendar = new GregorianCalendar(year, month - 1, day); pos.setIndex(offset); return calendar.getTime(); } if (hasT) { hour = parseInt(date, offset += 1, offset += 2); if (checkOffset(date, offset, ':')) { offset += 1; } minutes = parseInt(date, offset, offset += 2); if (checkOffset(date, offset, ':')) { offset += 1; } if (date.length() > offset) { char c = date.charAt(offset); if (c != 'Z' && c != '+' && c != '-') { seconds = parseInt(date, offset, offset += 2); if (seconds > 59 && seconds < 63) seconds = 59; if (checkOffset(date, offset, '.')) { offset += 1; int endOffset = indexOfNonDigit(date, offset + 1); int parseEndOffset = Math.min(endOffset, offset + 3); int fraction = parseInt(date, offset, parseEndOffset); switch (parseEndOffset - offset) { case 2: milliseconds = fraction * 10; break; case 1: milliseconds = fraction * 100; break; default: milliseconds = fraction; } offset = endOffset; } } } } if (date.length() <= offset) { throw new IllegalArgumentException("No time zone indicator"); } TimeZone timezone = null; char timezoneIndicator = date.charAt(offset); if (timezoneIndicator == 'Z') { timezone = TIMEZONE_UTC; offset += 1; } else if (timezoneIndicator == '+' || timezoneIndicator == '-') { String timezoneOffset = date.substring(offset); timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + "00"; offset += timezoneOffset.length(); if ("+0000".equals(timezoneOffset) || "+00:00".equals(timezoneOffset)) { timezone = TIMEZONE_UTC; } else { String timezoneId = "GMT" + timezoneOffset; timezone = TimeZone.getTimeZone(timezoneId); String act = timezone.getID(); if (!act.equals(timezoneId)) { String cleaned = act.replace(":", ""); if (!cleaned.equals(timezoneId)) { throw new IndexOutOfBoundsException("Mismatching time zone indicator: "+timezoneId+" given, resolves to " +timezone.getID()); } } } } else { throw new IndexOutOfBoundsException("Invalid time zone indicator '" + timezoneIndicator+"'"); } Calendar calendar = new GregorianCalendar(timezone); calendar.setLenient(false); calendar.set(Calendar.YEAR, year); calendar.set(Calendar.MONTH, month - 1); calendar.set(Calendar.DAY_OF_MONTH, day); calendar.set(Calendar.HOUR_OF_DAY, hour); calendar.set(Calendar.MINUTE, minutes); calendar.set(Calendar.SECOND, seconds); calendar.set(Calendar.MILLISECOND, milliseconds); pos.setIndex(offset); return calendar.getTime(); } catch (IndexOutOfBoundsException e) { fail = e; } catch (NumberFormatException e) { fail = e; } catch (IllegalArgumentException e) { fail = e; } String input = (date == null) ? null : ('"' + date + "'"); String msg = fail.getMessage(); if (msg == null || msg.isEmpty()) { msg = "("+fail.getClass().getName()+")"; } ParseException ex = new ParseException("Failed to parse date [" + input + "]: " + msg, pos.getIndex()); ex.initCause(fail); throw ex; } static String format(Date date); static String format(Date date, boolean millis); static String format(Date date, boolean millis, TimeZone tz); static Date parse(String date, ParsePosition pos); }
ISO8601Utils { public static String format(Date date, boolean millis) { return format(date, millis, TIMEZONE_UTC); } static String format(Date date); static String format(Date date, boolean millis); static String format(Date date, boolean millis, TimeZone tz); static Date parse(String date, ParsePosition pos); }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
JsonAdapterAnnotationTypeAdapterFactory implements TypeAdapterFactory { @SuppressWarnings("unchecked") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) { JsonAdapter annotation = targetType.getRawType().getAnnotation(JsonAdapter.class); if (annotation == null) { return null; } return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation); } JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor); @SuppressWarnings("unchecked") @Override TypeAdapter<T> create(Gson gson, TypeToken<T> targetType); }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
JsonReader implements Closeable { public void endObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_OBJECT) { stackSize--; pathNames[stackSize] = null; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException("Expected END_OBJECT but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { @Override public String toString() { return getClass().getSimpleName() + " at line " + getLineNumber() + " column " + getColumnNumber(); } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public boolean nextBoolean() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_TRUE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return true; } else if (p == PEEKED_FALSE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return false; } throw new IllegalStateException("Expected a boolean but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public double nextDouble() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return (double) peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"'); } else if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else if (p != PEEKED_BUFFERED) { throw new IllegalStateException("Expected a double but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peeked = PEEKED_BUFFERED; double result = Double.parseDouble(peekedString); if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { throw new MalformedJsonException("JSON forbids NaN and infinities: " + result + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public String nextString() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED) { result = nextQuotedValue('"'); } else if (p == PEEKED_BUFFERED) { result = peekedString; peekedString = null; } else if (p == PEEKED_LONG) { result = Long.toString(peekedLong); } else if (p == PEEKED_NUMBER) { result = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else { throw new IllegalStateException("Expected a string but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public String nextName() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED_NAME) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED_NAME) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED_NAME) { result = nextQuotedValue('"'); } else { throw new IllegalStateException("Expected a name but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peeked = PEEKED_NONE; pathNames[stackSize - 1] = result; return result; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public boolean hasNext() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public void nextNull() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_NULL) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; } else { throw new IllegalStateException("Expected null but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public String getPath() { StringBuilder result = new StringBuilder().append('$'); for (int i = 0, size = stackSize; i < size; i++) { switch (stack[i]) { case JsonScope.EMPTY_ARRAY: case JsonScope.NONEMPTY_ARRAY: result.append('[').append(pathIndices[i]).append(']'); break; case JsonScope.EMPTY_OBJECT: case JsonScope.DANGLING_NAME: case JsonScope.NONEMPTY_OBJECT: result.append('.'); if (pathNames[i] != null) { result.append(pathNames[i]); } break; case JsonScope.NONEMPTY_DOCUMENT: case JsonScope.EMPTY_DOCUMENT: case JsonScope.CLOSED: break; } } return result.toString(); } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public void skipValue() throws IOException { int count = 0; do { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); count++; } else if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); count++; } else if (p == PEEKED_END_ARRAY) { stackSize--; count--; } else if (p == PEEKED_END_OBJECT) { stackSize--; count--; } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) { skipUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) { skipQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) { skipQuotedValue('"'); } else if (p == PEEKED_NUMBER) { pos += peekedNumberLength; } peeked = PEEKED_NONE; } while (count != 0); pathIndices[stackSize - 1]++; pathNames[stackSize - 1] = "null"; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public void beginArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); pathIndices[stackSize - 1] = 0; peeked = PEEKED_NONE; } else { throw new IllegalStateException("Expected BEGIN_ARRAY but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public void beginObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); peeked = PEEKED_NONE; } else { throw new IllegalStateException("Expected BEGIN_OBJECT but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public final void setLenient(boolean lenient) { this.lenient = lenient; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public void endArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_ARRAY) { stackSize--; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException("Expected END_ARRAY but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public JsonToken peek() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } switch (p) { case PEEKED_BEGIN_OBJECT: return JsonToken.BEGIN_OBJECT; case PEEKED_END_OBJECT: return JsonToken.END_OBJECT; case PEEKED_BEGIN_ARRAY: return JsonToken.BEGIN_ARRAY; case PEEKED_END_ARRAY: return JsonToken.END_ARRAY; case PEEKED_SINGLE_QUOTED_NAME: case PEEKED_DOUBLE_QUOTED_NAME: case PEEKED_UNQUOTED_NAME: return JsonToken.NAME; case PEEKED_TRUE: case PEEKED_FALSE: return JsonToken.BOOLEAN; case PEEKED_NULL: return JsonToken.NULL; case PEEKED_SINGLE_QUOTED: case PEEKED_DOUBLE_QUOTED: case PEEKED_UNQUOTED: case PEEKED_BUFFERED: return JsonToken.STRING; case PEEKED_LONG: case PEEKED_NUMBER: return JsonToken.NUMBER; case PEEKED_EOF: return JsonToken.END_DOCUMENT; default: throw new AssertionError(); } } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public long nextLong() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"'); } try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException("Expected a long but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); long result = (long) asDouble; if (result != asDouble) { throw new NumberFormatException("Expected a long but was " + peekedString + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public void close() throws IOException { peeked = PEEKED_NONE; stack[0] = JsonScope.CLOSED; stackSize = 1; in.close(); } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public final boolean isLenient() { return lenient; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public int nextInt() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } int result; if (p == PEEKED_LONG) { result = (int) peekedLong; if (peekedLong != result) { throw new NumberFormatException("Expected an int but was " + peekedLong + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"'); } try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException("Expected an int but was " + peek() + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); result = (int) asDouble; if (result != asDouble) { throw new NumberFormatException("Expected an int but was " + peekedString + " at line " + getLineNumber() + " column " + getColumnNumber() + " path " + getPath()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
UnsafeAllocator { public abstract <T> T newInstance(Class<T> c) throws Exception; abstract T newInstance(Class<T> c); static UnsafeAllocator create(); }
UnsafeAllocator { public static UnsafeAllocator create() { try { Class<?> unsafeClass = Class.forName("sun.misc.Unsafe"); Field f = unsafeClass.getDeclaredField("theUnsafe"); f.setAccessible(true); final Object unsafe = f.get(null); final Method allocateInstance = unsafeClass.getMethod("allocateInstance", Class.class); return new UnsafeAllocator() { @Override @SuppressWarnings("unchecked") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) allocateInstance.invoke(unsafe, c); } }; } catch (Exception ignored) { } try { Method getConstructorId = ObjectStreamClass.class .getDeclaredMethod("getConstructorId", Class.class); getConstructorId.setAccessible(true); final int constructorId = (Integer) getConstructorId.invoke(null, Object.class); final Method newInstance = ObjectStreamClass.class .getDeclaredMethod("newInstance", Class.class, int.class); newInstance.setAccessible(true); return new UnsafeAllocator() { @Override @SuppressWarnings("unchecked") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) newInstance.invoke(null, c, constructorId); } }; } catch (Exception ignored) { } try { final Method newInstance = ObjectInputStream.class .getDeclaredMethod("newInstance", Class.class, Class.class); newInstance.setAccessible(true); return new UnsafeAllocator() { @Override @SuppressWarnings("unchecked") public <T> T newInstance(Class<T> c) throws Exception { assertInstantiable(c); return (T) newInstance.invoke(null, c, Object.class); } }; } catch (Exception ignored) { } return new UnsafeAllocator() { @Override public <T> T newInstance(Class<T> c) { throw new UnsupportedOperationException("Cannot allocate " + c); } }; } abstract T newInstance(Class<T> c); static UnsafeAllocator create(); }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
JsonWriter implements Closeable, Flushable { public final void setLenient(boolean lenient) { this.lenient = lenient; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonTreeWriter extends JsonWriter { @Override public JsonWriter name(String name) throws IOException { if (stack.isEmpty() || pendingName != null) { throw new IllegalStateException(); } JsonElement element = peek(); if (element instanceof JsonObject) { pendingName = name; return this; } throw new IllegalStateException(); } JsonTreeWriter(); JsonElement get(); @Override JsonWriter beginArray(); @Override JsonWriter endArray(); @Override JsonWriter beginObject(); @Override JsonWriter endObject(); @Override JsonWriter name(String name); @Override JsonWriter value(String value); @Override JsonWriter nullValue(); @Override JsonWriter value(boolean value); @Override JsonWriter value(Boolean value); @Override JsonWriter value(double value); @Override JsonWriter value(long value); @Override JsonWriter value(Number value); @Override void flush(); @Override void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter jsonValue(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.append(value); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter value(double value) throws IOException { if (Double.isNaN(value) || Double.isInfinite(value)) { throw new IllegalArgumentException("Numeric values must be finite, but was " + value); } writeDeferredName(); beforeValue(); out.append(Double.toString(value)); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public void close() throws IOException { out.close(); int size = stackSize; if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) { throw new IOException("Incomplete document"); } stackSize = 0; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings("unchecked") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return "Factory[type=" + boxed.getName() + "+" + unboxed.getName() + ",adapter=" + typeAdapter + "]"; } }; } private TypeAdapters(); static TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter); @SuppressWarnings("rawtypes") static final TypeAdapter<Class> CLASS; static final TypeAdapterFactory CLASS_FACTORY; static final TypeAdapter<BitSet> BIT_SET; static final TypeAdapterFactory BIT_SET_FACTORY; static final TypeAdapter<Boolean> BOOLEAN; static final TypeAdapter<Boolean> BOOLEAN_AS_STRING; static final TypeAdapterFactory BOOLEAN_FACTORY; static final TypeAdapter<Number> BYTE; static final TypeAdapterFactory BYTE_FACTORY; static final TypeAdapter<Number> SHORT; static final TypeAdapterFactory SHORT_FACTORY; static final TypeAdapter<Number> INTEGER; static final TypeAdapterFactory INTEGER_FACTORY; static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER; static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY; static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN; static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY; static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY; static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY; static final TypeAdapter<Number> LONG; static final TypeAdapter<Number> FLOAT; static final TypeAdapter<Number> DOUBLE; static final TypeAdapter<Number> NUMBER; static final TypeAdapterFactory NUMBER_FACTORY; static final TypeAdapter<Character> CHARACTER; static final TypeAdapterFactory CHARACTER_FACTORY; static final TypeAdapter<String> STRING; static final TypeAdapter<BigDecimal> BIG_DECIMAL; static final TypeAdapter<BigInteger> BIG_INTEGER; static final TypeAdapterFactory STRING_FACTORY; static final TypeAdapter<StringBuilder> STRING_BUILDER; static final TypeAdapterFactory STRING_BUILDER_FACTORY; static final TypeAdapter<StringBuffer> STRING_BUFFER; static final TypeAdapterFactory STRING_BUFFER_FACTORY; static final TypeAdapter<URL> URL; static final TypeAdapterFactory URL_FACTORY; static final TypeAdapter<URI> URI; static final TypeAdapterFactory URI_FACTORY; static final TypeAdapter<InetAddress> INET_ADDRESS; static final TypeAdapterFactory INET_ADDRESS_FACTORY; static final TypeAdapter<UUID> UUID; static final TypeAdapterFactory UUID_FACTORY; static final TypeAdapter<Currency> CURRENCY; static final TypeAdapterFactory CURRENCY_FACTORY; static final TypeAdapterFactory TIMESTAMP_FACTORY; static final TypeAdapter<Calendar> CALENDAR; static final TypeAdapterFactory CALENDAR_FACTORY; static final TypeAdapter<Locale> LOCALE; static final TypeAdapterFactory LOCALE_FACTORY; static final TypeAdapter<JsonElement> JSON_ELEMENT; static final TypeAdapterFactory JSON_ELEMENT_FACTORY; static final TypeAdapterFactory ENUM_FACTORY; }
JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(double value) throws IOException { if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) { throw new IllegalArgumentException("JSON forbids NaN and infinities: " + value); } put(new JsonPrimitive(value)); return this; } JsonTreeWriter(); JsonElement get(); @Override JsonWriter beginArray(); @Override JsonWriter endArray(); @Override JsonWriter beginObject(); @Override JsonWriter endObject(); @Override JsonWriter name(String name); @Override JsonWriter value(String value); @Override JsonWriter nullValue(); @Override JsonWriter value(boolean value); @Override JsonWriter value(Boolean value); @Override JsonWriter value(double value); @Override JsonWriter value(long value); @Override JsonWriter value(Number value); @Override void flush(); @Override void close(); }
JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(Number value) throws IOException { if (value == null) { return nullValue(); } if (!isLenient()) { double d = value.doubleValue(); if (Double.isNaN(d) || Double.isInfinite(d)) { throw new IllegalArgumentException("JSON forbids NaN and infinities: " + value); } } put(new JsonPrimitive(value)); return this; } JsonTreeWriter(); JsonElement get(); @Override JsonWriter beginArray(); @Override JsonWriter endArray(); @Override JsonWriter beginObject(); @Override JsonWriter endObject(); @Override JsonWriter name(String name); @Override JsonWriter value(String value); @Override JsonWriter nullValue(); @Override JsonWriter value(boolean value); @Override JsonWriter value(Boolean value); @Override JsonWriter value(double value); @Override JsonWriter value(long value); @Override JsonWriter value(Number value); @Override void flush(); @Override void close(); }
JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } put(new JsonPrimitive(value)); return this; } JsonTreeWriter(); JsonElement get(); @Override JsonWriter beginArray(); @Override JsonWriter endArray(); @Override JsonWriter beginObject(); @Override JsonWriter endObject(); @Override JsonWriter name(String name); @Override JsonWriter value(String value); @Override JsonWriter nullValue(); @Override JsonWriter value(boolean value); @Override JsonWriter value(Boolean value); @Override JsonWriter value(double value); @Override JsonWriter value(long value); @Override JsonWriter value(Number value); @Override void flush(); @Override void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.write(value ? "true" : "false"); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter endArray() throws IOException { return close(EMPTY_ARRAY, NONEMPTY_ARRAY, "]"); } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(boolean value) throws IOException { put(new JsonPrimitive(value)); return this; } JsonTreeWriter(); JsonElement get(); @Override JsonWriter beginArray(); @Override JsonWriter endArray(); @Override JsonWriter beginObject(); @Override JsonWriter endObject(); @Override JsonWriter name(String name); @Override JsonWriter value(String value); @Override JsonWriter nullValue(); @Override JsonWriter value(boolean value); @Override JsonWriter value(Boolean value); @Override JsonWriter value(double value); @Override JsonWriter value(long value); @Override JsonWriter value(Number value); @Override void flush(); @Override void close(); }
JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } put(new JsonPrimitive(value)); return this; } JsonTreeWriter(); JsonElement get(); @Override JsonWriter beginArray(); @Override JsonWriter endArray(); @Override JsonWriter beginObject(); @Override JsonWriter endObject(); @Override JsonWriter name(String name); @Override JsonWriter value(String value); @Override JsonWriter nullValue(); @Override JsonWriter value(boolean value); @Override JsonWriter value(Boolean value); @Override JsonWriter value(double value); @Override JsonWriter value(long value); @Override JsonWriter value(Number value); @Override void flush(); @Override void close(); }
JsonWriter implements Closeable, Flushable { public void flush() throws IOException { if (stackSize == 0) { throw new IllegalStateException("JsonWriter is closed."); } out.flush(); } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonTreeWriter extends JsonWriter { @Override public JsonWriter value(long value) throws IOException { put(new JsonPrimitive(value)); return this; } JsonTreeWriter(); JsonElement get(); @Override JsonWriter beginArray(); @Override JsonWriter endArray(); @Override JsonWriter beginObject(); @Override JsonWriter endObject(); @Override JsonWriter name(String name); @Override JsonWriter value(String value); @Override JsonWriter nullValue(); @Override JsonWriter value(boolean value); @Override JsonWriter value(Boolean value); @Override JsonWriter value(double value); @Override JsonWriter value(long value); @Override JsonWriter value(Number value); @Override void flush(); @Override void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter value(boolean value) throws IOException { writeDeferredName(); beforeValue(); out.write(value ? "true" : "false"); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); string(value); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
TypeAdapters { public static <T1> TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings("unchecked") @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) { final Class<? super T2> requestedType = typeToken.getRawType(); if (!clazz.isAssignableFrom(requestedType)) { return null; } return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException("Expected a " + requestedType.getName() + " but was " + result.getClass().getName()); } return result; } }; } @Override public String toString() { return "Factory[typeHierarchy=" + clazz.getName() + ",adapter=" + typeAdapter + "]"; } }; } private TypeAdapters(); static TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter); @SuppressWarnings("rawtypes") static final TypeAdapter<Class> CLASS; static final TypeAdapterFactory CLASS_FACTORY; static final TypeAdapter<BitSet> BIT_SET; static final TypeAdapterFactory BIT_SET_FACTORY; static final TypeAdapter<Boolean> BOOLEAN; static final TypeAdapter<Boolean> BOOLEAN_AS_STRING; static final TypeAdapterFactory BOOLEAN_FACTORY; static final TypeAdapter<Number> BYTE; static final TypeAdapterFactory BYTE_FACTORY; static final TypeAdapter<Number> SHORT; static final TypeAdapterFactory SHORT_FACTORY; static final TypeAdapter<Number> INTEGER; static final TypeAdapterFactory INTEGER_FACTORY; static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER; static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY; static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN; static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY; static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY; static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY; static final TypeAdapter<Number> LONG; static final TypeAdapter<Number> FLOAT; static final TypeAdapter<Number> DOUBLE; static final TypeAdapter<Number> NUMBER; static final TypeAdapterFactory NUMBER_FACTORY; static final TypeAdapter<Character> CHARACTER; static final TypeAdapterFactory CHARACTER_FACTORY; static final TypeAdapter<String> STRING; static final TypeAdapter<BigDecimal> BIG_DECIMAL; static final TypeAdapter<BigInteger> BIG_INTEGER; static final TypeAdapterFactory STRING_FACTORY; static final TypeAdapter<StringBuilder> STRING_BUILDER; static final TypeAdapterFactory STRING_BUILDER_FACTORY; static final TypeAdapter<StringBuffer> STRING_BUFFER; static final TypeAdapterFactory STRING_BUFFER_FACTORY; static final TypeAdapter<URL> URL; static final TypeAdapterFactory URL_FACTORY; static final TypeAdapter<URI> URI; static final TypeAdapterFactory URI_FACTORY; static final TypeAdapter<InetAddress> INET_ADDRESS; static final TypeAdapterFactory INET_ADDRESS_FACTORY; static final TypeAdapter<UUID> UUID; static final TypeAdapterFactory UUID_FACTORY; static final TypeAdapter<Currency> CURRENCY; static final TypeAdapterFactory CURRENCY_FACTORY; static final TypeAdapterFactory TIMESTAMP_FACTORY; static final TypeAdapter<Calendar> CALENDAR; static final TypeAdapterFactory CALENDAR_FACTORY; static final TypeAdapter<Locale> LOCALE; static final TypeAdapterFactory LOCALE_FACTORY; static final TypeAdapter<JsonElement> JSON_ELEMENT; static final TypeAdapterFactory JSON_ELEMENT_FACTORY; static final TypeAdapterFactory ENUM_FACTORY; }
JsonWriter implements Closeable, Flushable { public JsonWriter value(Number value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); String string = value.toString(); if (!lenient && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) { throw new IllegalArgumentException("Numeric values must be finite, but was " + value); } beforeValue(); out.append(string); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public final void setHtmlSafe(boolean htmlSafe) { this.htmlSafe = htmlSafe; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
TypeAdapters { public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings("unchecked") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return "Factory[type=" + base.getName() + "+" + sub.getName() + ",adapter=" + typeAdapter + "]"; } }; } private TypeAdapters(); static TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter); @SuppressWarnings("rawtypes") static final TypeAdapter<Class> CLASS; static final TypeAdapterFactory CLASS_FACTORY; static final TypeAdapter<BitSet> BIT_SET; static final TypeAdapterFactory BIT_SET_FACTORY; static final TypeAdapter<Boolean> BOOLEAN; static final TypeAdapter<Boolean> BOOLEAN_AS_STRING; static final TypeAdapterFactory BOOLEAN_FACTORY; static final TypeAdapter<Number> BYTE; static final TypeAdapterFactory BYTE_FACTORY; static final TypeAdapter<Number> SHORT; static final TypeAdapterFactory SHORT_FACTORY; static final TypeAdapter<Number> INTEGER; static final TypeAdapterFactory INTEGER_FACTORY; static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER; static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY; static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN; static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY; static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY; static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY; static final TypeAdapter<Number> LONG; static final TypeAdapter<Number> FLOAT; static final TypeAdapter<Number> DOUBLE; static final TypeAdapter<Number> NUMBER; static final TypeAdapterFactory NUMBER_FACTORY; static final TypeAdapter<Character> CHARACTER; static final TypeAdapterFactory CHARACTER_FACTORY; static final TypeAdapter<String> STRING; static final TypeAdapter<BigDecimal> BIG_DECIMAL; static final TypeAdapter<BigInteger> BIG_INTEGER; static final TypeAdapterFactory STRING_FACTORY; static final TypeAdapter<StringBuilder> STRING_BUILDER; static final TypeAdapterFactory STRING_BUILDER_FACTORY; static final TypeAdapter<StringBuffer> STRING_BUFFER; static final TypeAdapterFactory STRING_BUFFER_FACTORY; static final TypeAdapter<URL> URL; static final TypeAdapterFactory URL_FACTORY; static final TypeAdapter<URI> URI; static final TypeAdapterFactory URI_FACTORY; static final TypeAdapter<InetAddress> INET_ADDRESS; static final TypeAdapterFactory INET_ADDRESS_FACTORY; static final TypeAdapter<UUID> UUID; static final TypeAdapterFactory UUID_FACTORY; static final TypeAdapter<Currency> CURRENCY; static final TypeAdapterFactory CURRENCY_FACTORY; static final TypeAdapterFactory TIMESTAMP_FACTORY; static final TypeAdapter<Calendar> CALENDAR; static final TypeAdapterFactory CALENDAR_FACTORY; static final TypeAdapter<Locale> LOCALE; static final TypeAdapterFactory LOCALE_FACTORY; static final TypeAdapter<JsonElement> JSON_ELEMENT; static final TypeAdapterFactory JSON_ELEMENT_FACTORY; static final TypeAdapterFactory ENUM_FACTORY; }
TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings("unchecked") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return "Factory[type=" + type.getName() + ",adapter=" + typeAdapter + "]"; } }; } private TypeAdapters(); static TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter); @SuppressWarnings("rawtypes") static final TypeAdapter<Class> CLASS; static final TypeAdapterFactory CLASS_FACTORY; static final TypeAdapter<BitSet> BIT_SET; static final TypeAdapterFactory BIT_SET_FACTORY; static final TypeAdapter<Boolean> BOOLEAN; static final TypeAdapter<Boolean> BOOLEAN_AS_STRING; static final TypeAdapterFactory BOOLEAN_FACTORY; static final TypeAdapter<Number> BYTE; static final TypeAdapterFactory BYTE_FACTORY; static final TypeAdapter<Number> SHORT; static final TypeAdapterFactory SHORT_FACTORY; static final TypeAdapter<Number> INTEGER; static final TypeAdapterFactory INTEGER_FACTORY; static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER; static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY; static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN; static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY; static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY; static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY; static final TypeAdapter<Number> LONG; static final TypeAdapter<Number> FLOAT; static final TypeAdapter<Number> DOUBLE; static final TypeAdapter<Number> NUMBER; static final TypeAdapterFactory NUMBER_FACTORY; static final TypeAdapter<Character> CHARACTER; static final TypeAdapterFactory CHARACTER_FACTORY; static final TypeAdapter<String> STRING; static final TypeAdapter<BigDecimal> BIG_DECIMAL; static final TypeAdapter<BigInteger> BIG_INTEGER; static final TypeAdapterFactory STRING_FACTORY; static final TypeAdapter<StringBuilder> STRING_BUILDER; static final TypeAdapterFactory STRING_BUILDER_FACTORY; static final TypeAdapter<StringBuffer> STRING_BUFFER; static final TypeAdapterFactory STRING_BUFFER_FACTORY; static final TypeAdapter<URL> URL; static final TypeAdapterFactory URL_FACTORY; static final TypeAdapter<URI> URI; static final TypeAdapterFactory URI_FACTORY; static final TypeAdapter<InetAddress> INET_ADDRESS; static final TypeAdapterFactory INET_ADDRESS_FACTORY; static final TypeAdapter<UUID> UUID; static final TypeAdapterFactory UUID_FACTORY; static final TypeAdapter<Currency> CURRENCY; static final TypeAdapterFactory CURRENCY_FACTORY; static final TypeAdapterFactory TIMESTAMP_FACTORY; static final TypeAdapter<Calendar> CALENDAR; static final TypeAdapterFactory CALENDAR_FACTORY; static final TypeAdapter<Locale> LOCALE; static final TypeAdapterFactory LOCALE_FACTORY; static final TypeAdapter<JsonElement> JSON_ELEMENT; static final TypeAdapterFactory JSON_ELEMENT_FACTORY; static final TypeAdapterFactory ENUM_FACTORY; }
JsonWriter implements Closeable, Flushable { public JsonWriter endObject() throws IOException { return close(EMPTY_OBJECT, NONEMPTY_OBJECT, "}"); } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter value(long value) throws IOException { writeDeferredName(); beforeValue(); out.write(Long.toString(value)); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter beginArray() throws IOException { writeDeferredName(); return open(EMPTY_ARRAY, "["); } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonTreeWriter extends JsonWriter { @Override public JsonWriter endArray() throws IOException { if (stack.isEmpty() || pendingName != null) { throw new IllegalStateException(); } JsonElement element = peek(); if (element instanceof JsonArray) { stack.remove(stack.size() - 1); return this; } throw new IllegalStateException(); } JsonTreeWriter(); JsonElement get(); @Override JsonWriter beginArray(); @Override JsonWriter endArray(); @Override JsonWriter beginObject(); @Override JsonWriter endObject(); @Override JsonWriter name(String name); @Override JsonWriter value(String value); @Override JsonWriter nullValue(); @Override JsonWriter value(boolean value); @Override JsonWriter value(Boolean value); @Override JsonWriter value(double value); @Override JsonWriter value(long value); @Override JsonWriter value(Number value); @Override void flush(); @Override void close(); }
JsonWriter implements Closeable, Flushable { public final boolean getSerializeNulls() { return serializeNulls; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonTreeWriter extends JsonWriter { @Override public JsonWriter endObject() throws IOException { if (stack.isEmpty() || pendingName != null) { throw new IllegalStateException(); } JsonElement element = peek(); if (element instanceof JsonObject) { stack.remove(stack.size() - 1); return this; } throw new IllegalStateException(); } JsonTreeWriter(); JsonElement get(); @Override JsonWriter beginArray(); @Override JsonWriter endArray(); @Override JsonWriter beginObject(); @Override JsonWriter endObject(); @Override JsonWriter name(String name); @Override JsonWriter value(String value); @Override JsonWriter nullValue(); @Override JsonWriter value(boolean value); @Override JsonWriter value(Boolean value); @Override JsonWriter value(double value); @Override JsonWriter value(long value); @Override JsonWriter value(Number value); @Override void flush(); @Override void close(); }
JsonTreeWriter extends JsonWriter { public JsonElement get() { if (!stack.isEmpty()) { throw new IllegalStateException("Expected one JSON element but was " + stack); } return product; } JsonTreeWriter(); JsonElement get(); @Override JsonWriter beginArray(); @Override JsonWriter endArray(); @Override JsonWriter beginObject(); @Override JsonWriter endObject(); @Override JsonWriter name(String name); @Override JsonWriter value(String value); @Override JsonWriter nullValue(); @Override JsonWriter value(boolean value); @Override JsonWriter value(Boolean value); @Override JsonWriter value(double value); @Override JsonWriter value(long value); @Override JsonWriter value(Number value); @Override void flush(); @Override void close(); }
JsonTreeWriter extends JsonWriter { @Override public JsonWriter beginObject() throws IOException { JsonObject object = new JsonObject(); put(object); stack.add(object); return this; } JsonTreeWriter(); JsonElement get(); @Override JsonWriter beginArray(); @Override JsonWriter endArray(); @Override JsonWriter beginObject(); @Override JsonWriter endObject(); @Override JsonWriter name(String name); @Override JsonWriter value(String value); @Override JsonWriter nullValue(); @Override JsonWriter value(boolean value); @Override JsonWriter value(Boolean value); @Override JsonWriter value(double value); @Override JsonWriter value(long value); @Override JsonWriter value(Number value); @Override void flush(); @Override void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter beginObject() throws IOException { writeDeferredName(); return open(EMPTY_OBJECT, "{"); } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonTreeWriter extends JsonWriter { @Override public JsonWriter nullValue() throws IOException { put(JsonNull.INSTANCE); return this; } JsonTreeWriter(); JsonElement get(); @Override JsonWriter beginArray(); @Override JsonWriter endArray(); @Override JsonWriter beginObject(); @Override JsonWriter endObject(); @Override JsonWriter name(String name); @Override JsonWriter value(String value); @Override JsonWriter nullValue(); @Override JsonWriter value(boolean value); @Override JsonWriter value(Boolean value); @Override JsonWriter value(double value); @Override JsonWriter value(long value); @Override JsonWriter value(Number value); @Override void flush(); @Override void close(); }
JsonWriter implements Closeable, Flushable { public final void setIndent(String indent) { if (indent.length() == 0) { this.indent = null; this.separator = ":"; } else { this.indent = indent; this.separator = ": "; } } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonTreeWriter extends JsonWriter { @Override public void flush() throws IOException { } JsonTreeWriter(); JsonElement get(); @Override JsonWriter beginArray(); @Override JsonWriter endArray(); @Override JsonWriter beginObject(); @Override JsonWriter endObject(); @Override JsonWriter name(String name); @Override JsonWriter value(String value); @Override JsonWriter nullValue(); @Override JsonWriter value(boolean value); @Override JsonWriter value(Boolean value); @Override JsonWriter value(double value); @Override JsonWriter value(long value); @Override JsonWriter value(Number value); @Override void flush(); @Override void close(); }
JsonWriter implements Closeable, Flushable { public final boolean isHtmlSafe() { return htmlSafe; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public boolean isLenient() { return lenient; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter name(String name) throws IOException { if (name == null) { throw new NullPointerException("name == null"); } if (deferredName != null) { throw new IllegalStateException(); } if (stackSize == 0) { throw new IllegalStateException("JsonWriter is closed."); } deferredName = name; return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public final void setSerializeNulls(boolean serializeNulls) { this.serializeNulls = serializeNulls; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter nullValue() throws IOException { if (deferredName != null) { if (serializeNulls) { writeDeferredName(); } else { deferredName = null; return this; } } beforeValue(); out.write("null"); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings("unchecked") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null; } }; } private TypeAdapters(); static TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter); @SuppressWarnings("rawtypes") static final TypeAdapter<Class> CLASS; static final TypeAdapterFactory CLASS_FACTORY; static final TypeAdapter<BitSet> BIT_SET; static final TypeAdapterFactory BIT_SET_FACTORY; static final TypeAdapter<Boolean> BOOLEAN; static final TypeAdapter<Boolean> BOOLEAN_AS_STRING; static final TypeAdapterFactory BOOLEAN_FACTORY; static final TypeAdapter<Number> BYTE; static final TypeAdapterFactory BYTE_FACTORY; static final TypeAdapter<Number> SHORT; static final TypeAdapterFactory SHORT_FACTORY; static final TypeAdapter<Number> INTEGER; static final TypeAdapterFactory INTEGER_FACTORY; static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER; static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY; static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN; static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY; static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY; static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY; static final TypeAdapter<Number> LONG; static final TypeAdapter<Number> FLOAT; static final TypeAdapter<Number> DOUBLE; static final TypeAdapter<Number> NUMBER; static final TypeAdapterFactory NUMBER_FACTORY; static final TypeAdapter<Character> CHARACTER; static final TypeAdapterFactory CHARACTER_FACTORY; static final TypeAdapter<String> STRING; static final TypeAdapter<BigDecimal> BIG_DECIMAL; static final TypeAdapter<BigInteger> BIG_INTEGER; static final TypeAdapterFactory STRING_FACTORY; static final TypeAdapter<StringBuilder> STRING_BUILDER; static final TypeAdapterFactory STRING_BUILDER_FACTORY; static final TypeAdapter<StringBuffer> STRING_BUFFER; static final TypeAdapterFactory STRING_BUFFER_FACTORY; static final TypeAdapter<URL> URL; static final TypeAdapterFactory URL_FACTORY; static final TypeAdapter<URI> URI; static final TypeAdapterFactory URI_FACTORY; static final TypeAdapter<InetAddress> INET_ADDRESS; static final TypeAdapterFactory INET_ADDRESS_FACTORY; static final TypeAdapter<UUID> UUID; static final TypeAdapterFactory UUID_FACTORY; static final TypeAdapter<Currency> CURRENCY; static final TypeAdapterFactory CURRENCY_FACTORY; static final TypeAdapterFactory TIMESTAMP_FACTORY; static final TypeAdapter<Calendar> CALENDAR; static final TypeAdapterFactory CALENDAR_FACTORY; static final TypeAdapter<Locale> LOCALE; static final TypeAdapterFactory LOCALE_FACTORY; static final TypeAdapter<JsonElement> JSON_ELEMENT; static final TypeAdapterFactory JSON_ELEMENT_FACTORY; static final TypeAdapterFactory ENUM_FACTORY; }
JsonTreeWriter extends JsonWriter { @Override public JsonWriter beginArray() throws IOException { JsonArray array = new JsonArray(); put(array); stack.add(array); return this; } JsonTreeWriter(); JsonElement get(); @Override JsonWriter beginArray(); @Override JsonWriter endArray(); @Override JsonWriter beginObject(); @Override JsonWriter endObject(); @Override JsonWriter name(String name); @Override JsonWriter value(String value); @Override JsonWriter nullValue(); @Override JsonWriter value(boolean value); @Override JsonWriter value(Boolean value); @Override JsonWriter value(double value); @Override JsonWriter value(long value); @Override JsonWriter value(Number value); @Override void flush(); @Override void close(); }
JsonTreeWriter extends JsonWriter { @Override public void close() throws IOException { if (!stack.isEmpty()) { throw new IOException("Incomplete document"); } stack.add(SENTINEL_CLOSED); } JsonTreeWriter(); JsonElement get(); @Override JsonWriter beginArray(); @Override JsonWriter endArray(); @Override JsonWriter beginObject(); @Override JsonWriter endObject(); @Override JsonWriter name(String name); @Override JsonWriter value(String value); @Override JsonWriter nullValue(); @Override JsonWriter value(boolean value); @Override JsonWriter value(Boolean value); @Override JsonWriter value(double value); @Override JsonWriter value(long value); @Override JsonWriter value(Number value); @Override void flush(); @Override void close(); }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ReflectiveTypeAdapterFactory implements TypeAdapterFactory { public boolean excludeField(Field f, boolean serialize) { return excludeField(f, serialize, excluder); } ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor, FieldNamingStrategy fieldNamingPolicy, Excluder excluder); boolean excludeField(Field f, boolean serialize); @Override TypeAdapter<T> create(Gson gson, final TypeToken<T> type); }
ReflectiveTypeAdapterFactory implements TypeAdapterFactory { @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) { Class<? super T> raw = type.getRawType(); if (!Object.class.isAssignableFrom(raw)) { return null; } ObjectConstructor<T> constructor = constructorConstructor.get(type); return new Adapter<T>(constructor, getBoundFields(gson, type, raw)); } ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor, FieldNamingStrategy fieldNamingPolicy, Excluder excluder); boolean excludeField(Field f, boolean serialize); @Override TypeAdapter<T> create(Gson gson, final TypeToken<T> type); }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings("unchecked") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return "Factory[type=" + boxed.getName() + "+" + unboxed.getName() + ",adapter=" + typeAdapter + "]"; } }; } private TypeAdapters(); static TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter); @SuppressWarnings("rawtypes") static final TypeAdapter<Class> CLASS; static final TypeAdapterFactory CLASS_FACTORY; static final TypeAdapter<BitSet> BIT_SET; static final TypeAdapterFactory BIT_SET_FACTORY; static final TypeAdapter<Boolean> BOOLEAN; static final TypeAdapter<Boolean> BOOLEAN_AS_STRING; static final TypeAdapterFactory BOOLEAN_FACTORY; static final TypeAdapter<Number> BYTE; static final TypeAdapterFactory BYTE_FACTORY; static final TypeAdapter<Number> SHORT; static final TypeAdapterFactory SHORT_FACTORY; static final TypeAdapter<Number> INTEGER; static final TypeAdapterFactory INTEGER_FACTORY; static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER; static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY; static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN; static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY; static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY; static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY; static final TypeAdapter<Number> LONG; static final TypeAdapter<Number> FLOAT; static final TypeAdapter<Number> DOUBLE; static final TypeAdapter<Number> NUMBER; static final TypeAdapterFactory NUMBER_FACTORY; static final TypeAdapter<Character> CHARACTER; static final TypeAdapterFactory CHARACTER_FACTORY; static final TypeAdapter<String> STRING; static final TypeAdapter<BigDecimal> BIG_DECIMAL; static final TypeAdapter<BigInteger> BIG_INTEGER; static final TypeAdapterFactory STRING_FACTORY; static final TypeAdapter<StringBuilder> STRING_BUILDER; static final TypeAdapterFactory STRING_BUILDER_FACTORY; static final TypeAdapter<StringBuffer> STRING_BUFFER; static final TypeAdapterFactory STRING_BUFFER_FACTORY; static final TypeAdapter<URL> URL; static final TypeAdapterFactory URL_FACTORY; static final TypeAdapter<URI> URI; static final TypeAdapterFactory URI_FACTORY; static final TypeAdapter<InetAddress> INET_ADDRESS; static final TypeAdapterFactory INET_ADDRESS_FACTORY; static final TypeAdapter<UUID> UUID; static final TypeAdapterFactory UUID_FACTORY; static final TypeAdapter<Currency> CURRENCY; static final TypeAdapterFactory CURRENCY_FACTORY; static final TypeAdapterFactory TIMESTAMP_FACTORY; static final TypeAdapter<Calendar> CALENDAR; static final TypeAdapterFactory CALENDAR_FACTORY; static final TypeAdapter<Locale> LOCALE; static final TypeAdapterFactory LOCALE_FACTORY; static final TypeAdapter<JsonElement> JSON_ELEMENT; static final TypeAdapterFactory JSON_ELEMENT_FACTORY; static final TypeAdapterFactory ENUM_FACTORY; }
TypeAdapters { public static <T1> TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings("unchecked") @Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) { final Class<? super T2> requestedType = typeToken.getRawType(); if (!clazz.isAssignableFrom(requestedType)) { return null; } return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException("Expected a " + requestedType.getName() + " but was " + result.getClass().getName()); } return result; } }; } @Override public String toString() { return "Factory[typeHierarchy=" + clazz.getName() + ",adapter=" + typeAdapter + "]"; } }; } private TypeAdapters(); static TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter); @SuppressWarnings("rawtypes") static final TypeAdapter<Class> CLASS; static final TypeAdapterFactory CLASS_FACTORY; static final TypeAdapter<BitSet> BIT_SET; static final TypeAdapterFactory BIT_SET_FACTORY; static final TypeAdapter<Boolean> BOOLEAN; static final TypeAdapter<Boolean> BOOLEAN_AS_STRING; static final TypeAdapterFactory BOOLEAN_FACTORY; static final TypeAdapter<Number> BYTE; static final TypeAdapterFactory BYTE_FACTORY; static final TypeAdapter<Number> SHORT; static final TypeAdapterFactory SHORT_FACTORY; static final TypeAdapter<Number> INTEGER; static final TypeAdapterFactory INTEGER_FACTORY; static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER; static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY; static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN; static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY; static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY; static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY; static final TypeAdapter<Number> LONG; static final TypeAdapter<Number> FLOAT; static final TypeAdapter<Number> DOUBLE; static final TypeAdapter<Number> NUMBER; static final TypeAdapterFactory NUMBER_FACTORY; static final TypeAdapter<Character> CHARACTER; static final TypeAdapterFactory CHARACTER_FACTORY; static final TypeAdapter<String> STRING; static final TypeAdapter<BigDecimal> BIG_DECIMAL; static final TypeAdapter<BigInteger> BIG_INTEGER; static final TypeAdapterFactory STRING_FACTORY; static final TypeAdapter<StringBuilder> STRING_BUILDER; static final TypeAdapterFactory STRING_BUILDER_FACTORY; static final TypeAdapter<StringBuffer> STRING_BUFFER; static final TypeAdapterFactory STRING_BUFFER_FACTORY; static final TypeAdapter<URL> URL; static final TypeAdapterFactory URL_FACTORY; static final TypeAdapter<URI> URI; static final TypeAdapterFactory URI_FACTORY; static final TypeAdapter<InetAddress> INET_ADDRESS; static final TypeAdapterFactory INET_ADDRESS_FACTORY; static final TypeAdapter<UUID> UUID; static final TypeAdapterFactory UUID_FACTORY; static final TypeAdapter<Currency> CURRENCY; static final TypeAdapterFactory CURRENCY_FACTORY; static final TypeAdapterFactory TIMESTAMP_FACTORY; static final TypeAdapter<Calendar> CALENDAR; static final TypeAdapterFactory CALENDAR_FACTORY; static final TypeAdapter<Locale> LOCALE; static final TypeAdapterFactory LOCALE_FACTORY; static final TypeAdapter<JsonElement> JSON_ELEMENT; static final TypeAdapterFactory JSON_ELEMENT_FACTORY; static final TypeAdapterFactory ENUM_FACTORY; }
TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings("unchecked") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null; } }; } private TypeAdapters(); static TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter); @SuppressWarnings("rawtypes") static final TypeAdapter<Class> CLASS; static final TypeAdapterFactory CLASS_FACTORY; static final TypeAdapter<BitSet> BIT_SET; static final TypeAdapterFactory BIT_SET_FACTORY; static final TypeAdapter<Boolean> BOOLEAN; static final TypeAdapter<Boolean> BOOLEAN_AS_STRING; static final TypeAdapterFactory BOOLEAN_FACTORY; static final TypeAdapter<Number> BYTE; static final TypeAdapterFactory BYTE_FACTORY; static final TypeAdapter<Number> SHORT; static final TypeAdapterFactory SHORT_FACTORY; static final TypeAdapter<Number> INTEGER; static final TypeAdapterFactory INTEGER_FACTORY; static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER; static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY; static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN; static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY; static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY; static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY; static final TypeAdapter<Number> LONG; static final TypeAdapter<Number> FLOAT; static final TypeAdapter<Number> DOUBLE; static final TypeAdapter<Number> NUMBER; static final TypeAdapterFactory NUMBER_FACTORY; static final TypeAdapter<Character> CHARACTER; static final TypeAdapterFactory CHARACTER_FACTORY; static final TypeAdapter<String> STRING; static final TypeAdapter<BigDecimal> BIG_DECIMAL; static final TypeAdapter<BigInteger> BIG_INTEGER; static final TypeAdapterFactory STRING_FACTORY; static final TypeAdapter<StringBuilder> STRING_BUILDER; static final TypeAdapterFactory STRING_BUILDER_FACTORY; static final TypeAdapter<StringBuffer> STRING_BUFFER; static final TypeAdapterFactory STRING_BUFFER_FACTORY; static final TypeAdapter<URL> URL; static final TypeAdapterFactory URL_FACTORY; static final TypeAdapter<URI> URI; static final TypeAdapterFactory URI_FACTORY; static final TypeAdapter<InetAddress> INET_ADDRESS; static final TypeAdapterFactory INET_ADDRESS_FACTORY; static final TypeAdapter<UUID> UUID; static final TypeAdapterFactory UUID_FACTORY; static final TypeAdapter<Currency> CURRENCY; static final TypeAdapterFactory CURRENCY_FACTORY; static final TypeAdapterFactory TIMESTAMP_FACTORY; static final TypeAdapter<Calendar> CALENDAR; static final TypeAdapterFactory CALENDAR_FACTORY; static final TypeAdapter<Locale> LOCALE; static final TypeAdapterFactory LOCALE_FACTORY; static final TypeAdapter<JsonElement> JSON_ELEMENT; static final TypeAdapterFactory JSON_ELEMENT_FACTORY; static final TypeAdapterFactory ENUM_FACTORY; }
TypeAdapters { public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings("unchecked") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { Class<? super T> rawType = typeToken.getRawType(); return (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return "Factory[type=" + base.getName() + "+" + sub.getName() + ",adapter=" + typeAdapter + "]"; } }; } private TypeAdapters(); static TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter); @SuppressWarnings("rawtypes") static final TypeAdapter<Class> CLASS; static final TypeAdapterFactory CLASS_FACTORY; static final TypeAdapter<BitSet> BIT_SET; static final TypeAdapterFactory BIT_SET_FACTORY; static final TypeAdapter<Boolean> BOOLEAN; static final TypeAdapter<Boolean> BOOLEAN_AS_STRING; static final TypeAdapterFactory BOOLEAN_FACTORY; static final TypeAdapter<Number> BYTE; static final TypeAdapterFactory BYTE_FACTORY; static final TypeAdapter<Number> SHORT; static final TypeAdapterFactory SHORT_FACTORY; static final TypeAdapter<Number> INTEGER; static final TypeAdapterFactory INTEGER_FACTORY; static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER; static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY; static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN; static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY; static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY; static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY; static final TypeAdapter<Number> LONG; static final TypeAdapter<Number> FLOAT; static final TypeAdapter<Number> DOUBLE; static final TypeAdapter<Number> NUMBER; static final TypeAdapterFactory NUMBER_FACTORY; static final TypeAdapter<Character> CHARACTER; static final TypeAdapterFactory CHARACTER_FACTORY; static final TypeAdapter<String> STRING; static final TypeAdapter<BigDecimal> BIG_DECIMAL; static final TypeAdapter<BigInteger> BIG_INTEGER; static final TypeAdapterFactory STRING_FACTORY; static final TypeAdapter<StringBuilder> STRING_BUILDER; static final TypeAdapterFactory STRING_BUILDER_FACTORY; static final TypeAdapter<StringBuffer> STRING_BUFFER; static final TypeAdapterFactory STRING_BUFFER_FACTORY; static final TypeAdapter<URL> URL; static final TypeAdapterFactory URL_FACTORY; static final TypeAdapter<URI> URI; static final TypeAdapterFactory URI_FACTORY; static final TypeAdapter<InetAddress> INET_ADDRESS; static final TypeAdapterFactory INET_ADDRESS_FACTORY; static final TypeAdapter<UUID> UUID; static final TypeAdapterFactory UUID_FACTORY; static final TypeAdapter<Currency> CURRENCY; static final TypeAdapterFactory CURRENCY_FACTORY; static final TypeAdapterFactory TIMESTAMP_FACTORY; static final TypeAdapter<Calendar> CALENDAR; static final TypeAdapterFactory CALENDAR_FACTORY; static final TypeAdapter<Locale> LOCALE; static final TypeAdapterFactory LOCALE_FACTORY; static final TypeAdapter<JsonElement> JSON_ELEMENT; static final TypeAdapterFactory JSON_ELEMENT_FACTORY; static final TypeAdapterFactory ENUM_FACTORY; }
TypeAdapters { public static <TT> TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter) { return new TypeAdapterFactory() { @SuppressWarnings("unchecked") @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) { return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null; } @Override public String toString() { return "Factory[type=" + type.getName() + ",adapter=" + typeAdapter + "]"; } }; } private TypeAdapters(); static TypeAdapterFactory newFactory( final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> type, final TypeAdapter<TT> typeAdapter); static TypeAdapterFactory newFactory( final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter); static TypeAdapterFactory newTypeHierarchyFactory( final Class<T1> clazz, final TypeAdapter<T1> typeAdapter); @SuppressWarnings("rawtypes") static final TypeAdapter<Class> CLASS; static final TypeAdapterFactory CLASS_FACTORY; static final TypeAdapter<BitSet> BIT_SET; static final TypeAdapterFactory BIT_SET_FACTORY; static final TypeAdapter<Boolean> BOOLEAN; static final TypeAdapter<Boolean> BOOLEAN_AS_STRING; static final TypeAdapterFactory BOOLEAN_FACTORY; static final TypeAdapter<Number> BYTE; static final TypeAdapterFactory BYTE_FACTORY; static final TypeAdapter<Number> SHORT; static final TypeAdapterFactory SHORT_FACTORY; static final TypeAdapter<Number> INTEGER; static final TypeAdapterFactory INTEGER_FACTORY; static final TypeAdapter<AtomicInteger> ATOMIC_INTEGER; static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY; static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN; static final TypeAdapterFactory ATOMIC_BOOLEAN_FACTORY; static final TypeAdapter<AtomicIntegerArray> ATOMIC_INTEGER_ARRAY; static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY; static final TypeAdapter<Number> LONG; static final TypeAdapter<Number> FLOAT; static final TypeAdapter<Number> DOUBLE; static final TypeAdapter<Number> NUMBER; static final TypeAdapterFactory NUMBER_FACTORY; static final TypeAdapter<Character> CHARACTER; static final TypeAdapterFactory CHARACTER_FACTORY; static final TypeAdapter<String> STRING; static final TypeAdapter<BigDecimal> BIG_DECIMAL; static final TypeAdapter<BigInteger> BIG_INTEGER; static final TypeAdapterFactory STRING_FACTORY; static final TypeAdapter<StringBuilder> STRING_BUILDER; static final TypeAdapterFactory STRING_BUILDER_FACTORY; static final TypeAdapter<StringBuffer> STRING_BUFFER; static final TypeAdapterFactory STRING_BUFFER_FACTORY; static final TypeAdapter<URL> URL; static final TypeAdapterFactory URL_FACTORY; static final TypeAdapter<URI> URI; static final TypeAdapterFactory URI_FACTORY; static final TypeAdapter<InetAddress> INET_ADDRESS; static final TypeAdapterFactory INET_ADDRESS_FACTORY; static final TypeAdapter<UUID> UUID; static final TypeAdapterFactory UUID_FACTORY; static final TypeAdapter<Currency> CURRENCY; static final TypeAdapterFactory CURRENCY_FACTORY; static final TypeAdapterFactory TIMESTAMP_FACTORY; static final TypeAdapter<Calendar> CALENDAR; static final TypeAdapterFactory CALENDAR_FACTORY; static final TypeAdapter<Locale> LOCALE; static final TypeAdapterFactory LOCALE_FACTORY; static final TypeAdapter<JsonElement> JSON_ELEMENT; static final TypeAdapterFactory JSON_ELEMENT_FACTORY; static final TypeAdapterFactory ENUM_FACTORY; }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
JsonTreeReader extends JsonReader { @Override public JsonToken peek() throws IOException { if (stackSize == 0) { return JsonToken.END_DOCUMENT; } Object o = peekStack(); if (o instanceof Iterator) { boolean isObject = stack[stackSize - 2] instanceof JsonObject; Iterator<?> iterator = (Iterator<?>) o; if (iterator.hasNext()) { if (isObject) { return JsonToken.NAME; } else { push(iterator.next()); return peek(); } } else { return isObject ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; } } else if (o instanceof JsonObject) { return JsonToken.BEGIN_OBJECT; } else if (o instanceof JsonArray) { return JsonToken.BEGIN_ARRAY; } else if (o instanceof JsonPrimitive) { JsonPrimitive primitive = (JsonPrimitive) o; if (primitive.isString()) { return JsonToken.STRING; } else if (primitive.isBoolean()) { return JsonToken.BOOLEAN; } else if (primitive.isNumber()) { return JsonToken.NUMBER; } else { throw new AssertionError(); } } else if (o instanceof JsonNull) { return JsonToken.NULL; } else if (o == SENTINEL_CLOSED) { throw new IllegalStateException("JsonReader is closed"); } else { throw new AssertionError(); } } JsonTreeReader(JsonElement element); @Override void beginArray(); @Override void endArray(); @Override void beginObject(); @Override void endObject(); @Override boolean hasNext(); @Override JsonToken peek(); @Override String nextName(); @Override String nextString(); @Override boolean nextBoolean(); @Override void nextNull(); @Override double nextDouble(); @Override long nextLong(); @Override int nextInt(); @Override void close(); @Override void skipValue(); @Override String toString(); void promoteNameToValue(); @Override String getPath(); }
JsonTreeReader extends JsonReader { @Override public String getPath() { StringBuilder result = new StringBuilder().append('$'); for (int i = 0; i < stackSize; i++) { if (stack[i] instanceof JsonArray) { if (stack[++i] instanceof Iterator) { result.append('[').append(pathIndices[i]).append(']'); } } else if (stack[i] instanceof JsonObject) { if (stack[++i] instanceof Iterator) { result.append('.'); if (pathNames[i] != null) { result.append(pathNames[i]); } } } } return result.toString(); } JsonTreeReader(JsonElement element); @Override void beginArray(); @Override void endArray(); @Override void beginObject(); @Override void endObject(); @Override boolean hasNext(); @Override JsonToken peek(); @Override String nextName(); @Override String nextString(); @Override boolean nextBoolean(); @Override void nextNull(); @Override double nextDouble(); @Override long nextLong(); @Override int nextInt(); @Override void close(); @Override void skipValue(); @Override String toString(); void promoteNameToValue(); @Override String getPath(); }
JsonTreeReader extends JsonReader { @Override public double nextDouble() throws IOException { JsonToken token = peek(); if (token != JsonToken.NUMBER && token != JsonToken.STRING) { throw new IllegalStateException( "Expected " + JsonToken.NUMBER + " but was " + token + locationString()); } double result = ((JsonPrimitive) peekStack()).getAsDouble(); if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) { throw new NumberFormatException("JSON forbids NaN and infinities: " + result); } popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } JsonTreeReader(JsonElement element); @Override void beginArray(); @Override void endArray(); @Override void beginObject(); @Override void endObject(); @Override boolean hasNext(); @Override JsonToken peek(); @Override String nextName(); @Override String nextString(); @Override boolean nextBoolean(); @Override void nextNull(); @Override double nextDouble(); @Override long nextLong(); @Override int nextInt(); @Override void close(); @Override void skipValue(); @Override String toString(); void promoteNameToValue(); @Override String getPath(); }
JsonTreeReader extends JsonReader { @Override public int nextInt() throws IOException { JsonToken token = peek(); if (token != JsonToken.NUMBER && token != JsonToken.STRING) { throw new IllegalStateException( "Expected " + JsonToken.NUMBER + " but was " + token + locationString()); } int result = ((JsonPrimitive) peekStack()).getAsInt(); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } JsonTreeReader(JsonElement element); @Override void beginArray(); @Override void endArray(); @Override void beginObject(); @Override void endObject(); @Override boolean hasNext(); @Override JsonToken peek(); @Override String nextName(); @Override String nextString(); @Override boolean nextBoolean(); @Override void nextNull(); @Override double nextDouble(); @Override long nextLong(); @Override int nextInt(); @Override void close(); @Override void skipValue(); @Override String toString(); void promoteNameToValue(); @Override String getPath(); }
JsonTreeReader extends JsonReader { @Override public void nextNull() throws IOException { expect(JsonToken.NULL); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } } JsonTreeReader(JsonElement element); @Override void beginArray(); @Override void endArray(); @Override void beginObject(); @Override void endObject(); @Override boolean hasNext(); @Override JsonToken peek(); @Override String nextName(); @Override String nextString(); @Override boolean nextBoolean(); @Override void nextNull(); @Override double nextDouble(); @Override long nextLong(); @Override int nextInt(); @Override void close(); @Override void skipValue(); @Override String toString(); void promoteNameToValue(); @Override String getPath(); }
JsonTreeReader extends JsonReader { @Override public boolean nextBoolean() throws IOException { expect(JsonToken.BOOLEAN); boolean result = ((JsonPrimitive) popStack()).getAsBoolean(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } JsonTreeReader(JsonElement element); @Override void beginArray(); @Override void endArray(); @Override void beginObject(); @Override void endObject(); @Override boolean hasNext(); @Override JsonToken peek(); @Override String nextName(); @Override String nextString(); @Override boolean nextBoolean(); @Override void nextNull(); @Override double nextDouble(); @Override long nextLong(); @Override int nextInt(); @Override void close(); @Override void skipValue(); @Override String toString(); void promoteNameToValue(); @Override String getPath(); }
JsonTreeReader extends JsonReader { @Override public String nextName() throws IOException { expect(JsonToken.NAME); Iterator<?> i = (Iterator<?>) peekStack(); Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next(); String result = (String) entry.getKey(); pathNames[stackSize - 1] = result; push(entry.getValue()); return result; } JsonTreeReader(JsonElement element); @Override void beginArray(); @Override void endArray(); @Override void beginObject(); @Override void endObject(); @Override boolean hasNext(); @Override JsonToken peek(); @Override String nextName(); @Override String nextString(); @Override boolean nextBoolean(); @Override void nextNull(); @Override double nextDouble(); @Override long nextLong(); @Override int nextInt(); @Override void close(); @Override void skipValue(); @Override String toString(); void promoteNameToValue(); @Override String getPath(); }
JsonTreeReader extends JsonReader { @Override public long nextLong() throws IOException { JsonToken token = peek(); if (token != JsonToken.NUMBER && token != JsonToken.STRING) { throw new IllegalStateException( "Expected " + JsonToken.NUMBER + " but was " + token + locationString()); } long result = ((JsonPrimitive) peekStack()).getAsLong(); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } JsonTreeReader(JsonElement element); @Override void beginArray(); @Override void endArray(); @Override void beginObject(); @Override void endObject(); @Override boolean hasNext(); @Override JsonToken peek(); @Override String nextName(); @Override String nextString(); @Override boolean nextBoolean(); @Override void nextNull(); @Override double nextDouble(); @Override long nextLong(); @Override int nextInt(); @Override void close(); @Override void skipValue(); @Override String toString(); void promoteNameToValue(); @Override String getPath(); }
JsonTreeReader extends JsonReader { public void promoteNameToValue() throws IOException { expect(JsonToken.NAME); Iterator<?> i = (Iterator<?>) peekStack(); Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next(); push(entry.getValue()); push(new JsonPrimitive((String) entry.getKey())); } JsonTreeReader(JsonElement element); @Override void beginArray(); @Override void endArray(); @Override void beginObject(); @Override void endObject(); @Override boolean hasNext(); @Override JsonToken peek(); @Override String nextName(); @Override String nextString(); @Override boolean nextBoolean(); @Override void nextNull(); @Override double nextDouble(); @Override long nextLong(); @Override int nextInt(); @Override void close(); @Override void skipValue(); @Override String toString(); void promoteNameToValue(); @Override String getPath(); }
JsonTreeReader extends JsonReader { @Override public void beginObject() throws IOException { expect(JsonToken.BEGIN_OBJECT); JsonObject object = (JsonObject) peekStack(); push(object.entrySet().iterator()); } JsonTreeReader(JsonElement element); @Override void beginArray(); @Override void endArray(); @Override void beginObject(); @Override void endObject(); @Override boolean hasNext(); @Override JsonToken peek(); @Override String nextName(); @Override String nextString(); @Override boolean nextBoolean(); @Override void nextNull(); @Override double nextDouble(); @Override long nextLong(); @Override int nextInt(); @Override void close(); @Override void skipValue(); @Override String toString(); void promoteNameToValue(); @Override String getPath(); }
JsonTreeReader extends JsonReader { @Override public boolean hasNext() throws IOException { JsonToken token = peek(); return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY; } JsonTreeReader(JsonElement element); @Override void beginArray(); @Override void endArray(); @Override void beginObject(); @Override void endObject(); @Override boolean hasNext(); @Override JsonToken peek(); @Override String nextName(); @Override String nextString(); @Override boolean nextBoolean(); @Override void nextNull(); @Override double nextDouble(); @Override long nextLong(); @Override int nextInt(); @Override void close(); @Override void skipValue(); @Override String toString(); void promoteNameToValue(); @Override String getPath(); }
JsonTreeReader extends JsonReader { @Override public void beginArray() throws IOException { expect(JsonToken.BEGIN_ARRAY); JsonArray array = (JsonArray) peekStack(); push(array.iterator()); pathIndices[stackSize - 1] = 0; } JsonTreeReader(JsonElement element); @Override void beginArray(); @Override void endArray(); @Override void beginObject(); @Override void endObject(); @Override boolean hasNext(); @Override JsonToken peek(); @Override String nextName(); @Override String nextString(); @Override boolean nextBoolean(); @Override void nextNull(); @Override double nextDouble(); @Override long nextLong(); @Override int nextInt(); @Override void close(); @Override void skipValue(); @Override String toString(); void promoteNameToValue(); @Override String getPath(); }
JsonTreeReader extends JsonReader { @Override public void endObject() throws IOException { expect(JsonToken.END_OBJECT); popStack(); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } } JsonTreeReader(JsonElement element); @Override void beginArray(); @Override void endArray(); @Override void beginObject(); @Override void endObject(); @Override boolean hasNext(); @Override JsonToken peek(); @Override String nextName(); @Override String nextString(); @Override boolean nextBoolean(); @Override void nextNull(); @Override double nextDouble(); @Override long nextLong(); @Override int nextInt(); @Override void close(); @Override void skipValue(); @Override String toString(); void promoteNameToValue(); @Override String getPath(); }
JsonTreeReader extends JsonReader { @Override public String nextString() throws IOException { JsonToken token = peek(); if (token != JsonToken.STRING && token != JsonToken.NUMBER) { throw new IllegalStateException( "Expected " + JsonToken.STRING + " but was " + token + locationString()); } String result = ((JsonPrimitive) popStack()).getAsString(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } return result; } JsonTreeReader(JsonElement element); @Override void beginArray(); @Override void endArray(); @Override void beginObject(); @Override void endObject(); @Override boolean hasNext(); @Override JsonToken peek(); @Override String nextName(); @Override String nextString(); @Override boolean nextBoolean(); @Override void nextNull(); @Override double nextDouble(); @Override long nextLong(); @Override int nextInt(); @Override void close(); @Override void skipValue(); @Override String toString(); void promoteNameToValue(); @Override String getPath(); }
JsonTreeReader extends JsonReader { @Override public void close() throws IOException { stack = new Object[] { SENTINEL_CLOSED }; stackSize = 1; } JsonTreeReader(JsonElement element); @Override void beginArray(); @Override void endArray(); @Override void beginObject(); @Override void endObject(); @Override boolean hasNext(); @Override JsonToken peek(); @Override String nextName(); @Override String nextString(); @Override boolean nextBoolean(); @Override void nextNull(); @Override double nextDouble(); @Override long nextLong(); @Override int nextInt(); @Override void close(); @Override void skipValue(); @Override String toString(); void promoteNameToValue(); @Override String getPath(); }
JsonTreeReader extends JsonReader { @Override public String toString() { return getClass().getSimpleName(); } JsonTreeReader(JsonElement element); @Override void beginArray(); @Override void endArray(); @Override void beginObject(); @Override void endObject(); @Override boolean hasNext(); @Override JsonToken peek(); @Override String nextName(); @Override String nextString(); @Override boolean nextBoolean(); @Override void nextNull(); @Override double nextDouble(); @Override long nextLong(); @Override int nextInt(); @Override void close(); @Override void skipValue(); @Override String toString(); void promoteNameToValue(); @Override String getPath(); }
JsonTreeReader extends JsonReader { @Override public void endArray() throws IOException { expect(JsonToken.END_ARRAY); popStack(); popStack(); if (stackSize > 0) { pathIndices[stackSize - 1]++; } } JsonTreeReader(JsonElement element); @Override void beginArray(); @Override void endArray(); @Override void beginObject(); @Override void endObject(); @Override boolean hasNext(); @Override JsonToken peek(); @Override String nextName(); @Override String nextString(); @Override boolean nextBoolean(); @Override void nextNull(); @Override double nextDouble(); @Override long nextLong(); @Override int nextInt(); @Override void close(); @Override void skipValue(); @Override String toString(); void promoteNameToValue(); @Override String getPath(); }
JsonTreeReader extends JsonReader { @Override public void skipValue() throws IOException { if (peek() == JsonToken.NAME) { nextName(); pathNames[stackSize - 2] = "null"; } else { popStack(); if (stackSize > 0) { pathNames[stackSize - 1] = "null"; } } if (stackSize > 0) { pathIndices[stackSize - 1]++; } } JsonTreeReader(JsonElement element); @Override void beginArray(); @Override void endArray(); @Override void beginObject(); @Override void endObject(); @Override boolean hasNext(); @Override JsonToken peek(); @Override String nextName(); @Override String nextString(); @Override boolean nextBoolean(); @Override void nextNull(); @Override double nextDouble(); @Override long nextLong(); @Override int nextInt(); @Override void close(); @Override void skipValue(); @Override String toString(); void promoteNameToValue(); @Override String getPath(); }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
JsonReader implements Closeable { public void endObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_OBJECT) { stackSize--; pathNames[stackSize] = null; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException("Expected END_OBJECT but was " + peek() + locationString()); } } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { @Override public String toString() { return getClass().getSimpleName() + locationString(); } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public boolean nextBoolean() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_TRUE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return true; } else if (p == PEEKED_FALSE) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return false; } throw new IllegalStateException("Expected a boolean but was " + peek() + locationString()); } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public double nextDouble() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return (double) peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"'); } else if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else if (p != PEEKED_BUFFERED) { throw new IllegalStateException("Expected a double but was " + peek() + locationString()); } peeked = PEEKED_BUFFERED; double result = Double.parseDouble(peekedString); if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { throw new MalformedJsonException( "JSON forbids NaN and infinities: " + result + locationString()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public String nextString() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED) { result = nextQuotedValue('"'); } else if (p == PEEKED_BUFFERED) { result = peekedString; peekedString = null; } else if (p == PEEKED_LONG) { result = Long.toString(peekedLong); } else if (p == PEEKED_NUMBER) { result = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else { throw new IllegalStateException("Expected a string but was " + peek() + locationString()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public String nextName() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } String result; if (p == PEEKED_UNQUOTED_NAME) { result = nextUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED_NAME) { result = nextQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED_NAME) { result = nextQuotedValue('"'); } else { throw new IllegalStateException("Expected a name but was " + peek() + locationString()); } peeked = PEEKED_NONE; pathNames[stackSize - 1] = result; return result; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public boolean hasNext() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public void nextNull() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_NULL) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; } else { throw new IllegalStateException("Expected null but was " + peek() + locationString()); } } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public String getPath() { StringBuilder result = new StringBuilder().append('$'); for (int i = 0, size = stackSize; i < size; i++) { switch (stack[i]) { case JsonScope.EMPTY_ARRAY: case JsonScope.NONEMPTY_ARRAY: result.append('[').append(pathIndices[i]).append(']'); break; case JsonScope.EMPTY_OBJECT: case JsonScope.DANGLING_NAME: case JsonScope.NONEMPTY_OBJECT: result.append('.'); if (pathNames[i] != null) { result.append(pathNames[i]); } break; case JsonScope.NONEMPTY_DOCUMENT: case JsonScope.EMPTY_DOCUMENT: case JsonScope.CLOSED: break; } } return result.toString(); } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public void skipValue() throws IOException { int count = 0; do { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); count++; } else if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); count++; } else if (p == PEEKED_END_ARRAY) { stackSize--; count--; } else if (p == PEEKED_END_OBJECT) { stackSize--; count--; } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) { skipUnquotedValue(); } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) { skipQuotedValue('\''); } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) { skipQuotedValue('"'); } else if (p == PEEKED_NUMBER) { pos += peekedNumberLength; } peeked = PEEKED_NONE; } while (count != 0); pathIndices[stackSize - 1]++; pathNames[stackSize - 1] = "null"; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public void beginArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_ARRAY) { push(JsonScope.EMPTY_ARRAY); pathIndices[stackSize - 1] = 0; peeked = PEEKED_NONE; } else { throw new IllegalStateException("Expected BEGIN_ARRAY but was " + peek() + locationString()); } } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public void beginObject() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_BEGIN_OBJECT) { push(JsonScope.EMPTY_OBJECT); peeked = PEEKED_NONE; } else { throw new IllegalStateException("Expected BEGIN_OBJECT but was " + peek() + locationString()); } } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public final void setLenient(boolean lenient) { this.lenient = lenient; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public void endArray() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_END_ARRAY) { stackSize--; pathIndices[stackSize - 1]++; peeked = PEEKED_NONE; } else { throw new IllegalStateException("Expected END_ARRAY but was " + peek() + locationString()); } } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public JsonToken peek() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } switch (p) { case PEEKED_BEGIN_OBJECT: return JsonToken.BEGIN_OBJECT; case PEEKED_END_OBJECT: return JsonToken.END_OBJECT; case PEEKED_BEGIN_ARRAY: return JsonToken.BEGIN_ARRAY; case PEEKED_END_ARRAY: return JsonToken.END_ARRAY; case PEEKED_SINGLE_QUOTED_NAME: case PEEKED_DOUBLE_QUOTED_NAME: case PEEKED_UNQUOTED_NAME: return JsonToken.NAME; case PEEKED_TRUE: case PEEKED_FALSE: return JsonToken.BOOLEAN; case PEEKED_NULL: return JsonToken.NULL; case PEEKED_SINGLE_QUOTED: case PEEKED_DOUBLE_QUOTED: case PEEKED_UNQUOTED: case PEEKED_BUFFERED: return JsonToken.STRING; case PEEKED_LONG: case PEEKED_NUMBER: return JsonToken.NUMBER; case PEEKED_EOF: return JsonToken.END_DOCUMENT; default: throw new AssertionError(); } } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public long nextLong() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } if (p == PEEKED_LONG) { peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return peekedLong; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"'); } try { long result = Long.parseLong(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException("Expected a long but was " + peek() + locationString()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); long result = (long) asDouble; if (result != asDouble) { throw new NumberFormatException("Expected a long but was " + peekedString + locationString()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public void close() throws IOException { peeked = PEEKED_NONE; stack[0] = JsonScope.CLOSED; stackSize = 1; in.close(); } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public final boolean isLenient() { return lenient; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
JsonReader implements Closeable { public int nextInt() throws IOException { int p = peeked; if (p == PEEKED_NONE) { p = doPeek(); } int result; if (p == PEEKED_LONG) { result = (int) peekedLong; if (peekedLong != result) { throw new NumberFormatException("Expected an int but was " + peekedLong + locationString()); } peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } if (p == PEEKED_NUMBER) { peekedString = new String(buffer, pos, peekedNumberLength); pos += peekedNumberLength; } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) { if (p == PEEKED_UNQUOTED) { peekedString = nextUnquotedValue(); } else { peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"'); } try { result = Integer.parseInt(peekedString); peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } catch (NumberFormatException ignored) { } } else { throw new IllegalStateException("Expected an int but was " + peek() + locationString()); } peeked = PEEKED_BUFFERED; double asDouble = Double.parseDouble(peekedString); result = (int) asDouble; if (result != asDouble) { throw new NumberFormatException("Expected an int but was " + peekedString + locationString()); } peekedString = null; peeked = PEEKED_NONE; pathIndices[stackSize - 1]++; return result; } JsonReader(Reader in); final void setLenient(boolean lenient); final boolean isLenient(); void beginArray(); void endArray(); void beginObject(); void endObject(); boolean hasNext(); JsonToken peek(); String nextName(); String nextString(); boolean nextBoolean(); void nextNull(); double nextDouble(); long nextLong(); int nextInt(); void close(); void skipValue(); @Override String toString(); String getPath(); }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Types { public static Class<?> getRawType(Type type) { if (type instanceof Class<?>) { return (Class<?>) type; } else if (type instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) type; Type rawType = parameterizedType.getRawType(); checkArgument(rawType instanceof Class); return (Class<?>) rawType; } else if (type instanceof GenericArrayType) { Type componentType = ((GenericArrayType)type).getGenericComponentType(); return Array.newInstance(getRawType(componentType), 0).getClass(); } else if (type instanceof TypeVariable) { return Object.class; } else if (type instanceof WildcardType) { return getRawType(((WildcardType) type).getUpperBounds()[0]); } else { String className = type == null ? "null" : type.getClass().getName(); throw new IllegalArgumentException("Expected a Class, ParameterizedType, or " + "GenericArrayType, but <" + type + "> is of type " + className); } } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) { if (context == Properties.class) { return new Type[] { String.class, String.class }; } Type mapType = getSupertype(context, contextRawType, Map.class); if (mapType instanceof ParameterizedType) { ParameterizedType mapParameterizedType = (ParameterizedType) mapType; return mapParameterizedType.getActualTypeArguments(); } return new Type[] { Object.class, Object.class }; } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static Type getCollectionElementType(Type context, Class<?> contextRawType) { Type collectionType = getSupertype(context, contextRawType, Collection.class); if (collectionType instanceof WildcardType) { collectionType = ((WildcardType)collectionType).getUpperBounds()[0]; } if (collectionType instanceof ParameterizedType) { return ((ParameterizedType) collectionType).getActualTypeArguments()[0]; } return Object.class; } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static Type getArrayComponentType(Type array) { return array instanceof GenericArrayType ? ((GenericArrayType) array).getGenericComponentType() : ((Class<?>) array).getComponentType(); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static boolean equals(Type a, Type b) { if (a == b) { return true; } else if (a instanceof Class) { return a.equals(b); } else if (a instanceof ParameterizedType) { if (!(b instanceof ParameterizedType)) { return false; } ParameterizedType pa = (ParameterizedType) a; ParameterizedType pb = (ParameterizedType) b; return equal(pa.getOwnerType(), pb.getOwnerType()) && pa.getRawType().equals(pb.getRawType()) && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments()); } else if (a instanceof GenericArrayType) { if (!(b instanceof GenericArrayType)) { return false; } GenericArrayType ga = (GenericArrayType) a; GenericArrayType gb = (GenericArrayType) b; return equals(ga.getGenericComponentType(), gb.getGenericComponentType()); } else if (a instanceof WildcardType) { if (!(b instanceof WildcardType)) { return false; } WildcardType wa = (WildcardType) a; WildcardType wb = (WildcardType) b; return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds()) && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds()); } else if (a instanceof TypeVariable) { if (!(b instanceof TypeVariable)) { return false; } TypeVariable<?> va = (TypeVariable<?>) a; TypeVariable<?> vb = (TypeVariable<?>) b; return va.getGenericDeclaration() == vb.getGenericDeclaration() && va.getName().equals(vb.getName()); } else { return false; } } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) { while (true) { if (toResolve instanceof TypeVariable) { TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve; toResolve = resolveTypeVariable(context, contextRawType, typeVariable); if (toResolve == typeVariable) { return toResolve; } } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) { Class<?> original = (Class<?>) toResolve; Type componentType = original.getComponentType(); Type newComponentType = resolve(context, contextRawType, componentType); return componentType == newComponentType ? original : arrayOf(newComponentType); } else if (toResolve instanceof GenericArrayType) { GenericArrayType original = (GenericArrayType) toResolve; Type componentType = original.getGenericComponentType(); Type newComponentType = resolve(context, contextRawType, componentType); return componentType == newComponentType ? original : arrayOf(newComponentType); } else if (toResolve instanceof ParameterizedType) { ParameterizedType original = (ParameterizedType) toResolve; Type ownerType = original.getOwnerType(); Type newOwnerType = resolve(context, contextRawType, ownerType); boolean changed = newOwnerType != ownerType; Type[] args = original.getActualTypeArguments(); for (int t = 0, length = args.length; t < length; t++) { Type resolvedTypeArgument = resolve(context, contextRawType, args[t]); if (resolvedTypeArgument != args[t]) { if (!changed) { args = args.clone(); changed = true; } args[t] = resolvedTypeArgument; } } return changed ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args) : original; } else if (toResolve instanceof WildcardType) { WildcardType original = (WildcardType) toResolve; Type[] originalLowerBound = original.getLowerBounds(); Type[] originalUpperBound = original.getUpperBounds(); if (originalLowerBound.length == 1) { Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]); if (lowerBound != originalLowerBound[0]) { return supertypeOf(lowerBound); } } else if (originalUpperBound.length == 1) { Type upperBound = resolve(context, contextRawType, originalUpperBound[0]); if (upperBound != originalUpperBound[0]) { return subtypeOf(upperBound); } } return original; } else { return toResolve; } } } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static WildcardType subtypeOf(Type bound) { Type[] upperBounds; if (bound instanceof WildcardType) { upperBounds = ((WildcardType) bound).getUpperBounds(); } else { upperBounds = new Type[] { bound }; } return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static Type canonicalize(Type type) { if (type instanceof Class) { Class<?> c = (Class<?>) type; return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c; } else if (type instanceof ParameterizedType) { ParameterizedType p = (ParameterizedType) type; return new ParameterizedTypeImpl(p.getOwnerType(), p.getRawType(), p.getActualTypeArguments()); } else if (type instanceof GenericArrayType) { GenericArrayType g = (GenericArrayType) type; return new GenericArrayTypeImpl(g.getGenericComponentType()); } else if (type instanceof WildcardType) { WildcardType w = (WildcardType) type; return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds()); } else { return type; } } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments) { return new ParameterizedTypeImpl(ownerType, rawType, typeArguments); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static WildcardType supertypeOf(Type bound) { Type[] lowerBounds; if (bound instanceof WildcardType) { lowerBounds = ((WildcardType) bound).getLowerBounds(); } else { lowerBounds = new Type[] { bound }; } return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static String typeToString(Type type) { return type instanceof Class ? ((Class<?>) type).getName() : type.toString(); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static GenericArrayType arrayOf(Type componentType) { return new GenericArrayTypeImpl(componentType); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
JsonWriter implements Closeable, Flushable { public void close() throws IOException { out.close(); int size = stackSize; if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) { throw new IOException("Incomplete document"); } stackSize = 0; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public final void setSerializeNulls(boolean serializeNulls) { this.serializeNulls = serializeNulls; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter value(double value) throws IOException { writeDeferredName(); if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) { throw new IllegalArgumentException("Numeric values must be finite, but was " + value); } beforeValue(); out.append(Double.toString(value)); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter endObject() throws IOException { return close(EMPTY_OBJECT, NONEMPTY_OBJECT, "}"); } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter value(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); string(value); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter beginObject() throws IOException { writeDeferredName(); return open(EMPTY_OBJECT, "{"); } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter endArray() throws IOException { return close(EMPTY_ARRAY, NONEMPTY_ARRAY, "]"); } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public final boolean getSerializeNulls() { return serializeNulls; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter name(String name) throws IOException { if (name == null) { throw new NullPointerException("name == null"); } if (deferredName != null) { throw new IllegalStateException(); } if (stackSize == 0) { throw new IllegalStateException("JsonWriter is closed."); } deferredName = name; return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter value(Number value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); String string = value.toString(); if (!lenient && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) { throw new IllegalArgumentException("Numeric values must be finite, but was " + value); } beforeValue(); out.append(string); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter value(long value) throws IOException { writeDeferredName(); beforeValue(); out.write(Long.toString(value)); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter value(Boolean value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.write(value ? "true" : "false"); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public boolean isLenient() { return lenient; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public final boolean isHtmlSafe() { return htmlSafe; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public final void setIndent(String indent) { if (indent.length() == 0) { this.indent = null; this.separator = ":"; } else { this.indent = indent; this.separator = ": "; } } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public final void setHtmlSafe(boolean htmlSafe) { this.htmlSafe = htmlSafe; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter beginArray() throws IOException { writeDeferredName(); return open(EMPTY_ARRAY, "["); } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public void flush() throws IOException { if (stackSize == 0) { throw new IllegalStateException("JsonWriter is closed."); } out.flush(); } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter jsonValue(String value) throws IOException { if (value == null) { return nullValue(); } writeDeferredName(); beforeValue(); out.append(value); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter value(boolean value) throws IOException { writeDeferredName(); beforeValue(); out.write(value ? "true" : "false"); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public final void setLenient(boolean lenient) { this.lenient = lenient; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
JsonWriter implements Closeable, Flushable { public JsonWriter nullValue() throws IOException { if (deferredName != null) { if (serializeNulls) { writeDeferredName(); } else { deferredName = null; return this; } } beforeValue(); out.write("null"); return this; } JsonWriter(Writer out); final void setIndent(String indent); final void setLenient(boolean lenient); boolean isLenient(); final void setHtmlSafe(boolean htmlSafe); final boolean isHtmlSafe(); final void setSerializeNulls(boolean serializeNulls); final boolean getSerializeNulls(); JsonWriter beginArray(); JsonWriter endArray(); JsonWriter beginObject(); JsonWriter endObject(); JsonWriter name(String name); JsonWriter value(String value); JsonWriter jsonValue(String value); JsonWriter nullValue(); JsonWriter value(boolean value); JsonWriter value(Boolean value); JsonWriter value(double value); JsonWriter value(long value); JsonWriter value(Number value); void flush(); void close(); }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Types { public static Class<?> getRawType(Type type) { if (type instanceof Class<?>) { return (Class<?>) type; } else if (type instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) type; Type rawType = parameterizedType.getRawType(); checkArgument(rawType instanceof Class); return (Class<?>) rawType; } else if (type instanceof GenericArrayType) { Type componentType = ((GenericArrayType)type).getGenericComponentType(); return Array.newInstance(getRawType(componentType), 0).getClass(); } else if (type instanceof TypeVariable) { return Object.class; } else if (type instanceof WildcardType) { return getRawType(((WildcardType) type).getUpperBounds()[0]); } else { String className = type == null ? "null" : type.getClass().getName(); throw new IllegalArgumentException("Expected a Class, ParameterizedType, or " + "GenericArrayType, but <" + type + "> is of type " + className); } } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) { if (context == Properties.class) { return new Type[] { String.class, String.class }; } Type mapType = getSupertype(context, contextRawType, Map.class); if (mapType instanceof ParameterizedType) { ParameterizedType mapParameterizedType = (ParameterizedType) mapType; return mapParameterizedType.getActualTypeArguments(); } return new Type[] { Object.class, Object.class }; } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static Type getCollectionElementType(Type context, Class<?> contextRawType) { Type collectionType = getSupertype(context, contextRawType, Collection.class); if (collectionType instanceof WildcardType) { collectionType = ((WildcardType)collectionType).getUpperBounds()[0]; } if (collectionType instanceof ParameterizedType) { return ((ParameterizedType) collectionType).getActualTypeArguments()[0]; } return Object.class; } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static Type getArrayComponentType(Type array) { return array instanceof GenericArrayType ? ((GenericArrayType) array).getGenericComponentType() : ((Class<?>) array).getComponentType(); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static boolean equals(Type a, Type b) { if (a == b) { return true; } else if (a instanceof Class) { return a.equals(b); } else if (a instanceof ParameterizedType) { if (!(b instanceof ParameterizedType)) { return false; } ParameterizedType pa = (ParameterizedType) a; ParameterizedType pb = (ParameterizedType) b; return equal(pa.getOwnerType(), pb.getOwnerType()) && pa.getRawType().equals(pb.getRawType()) && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments()); } else if (a instanceof GenericArrayType) { if (!(b instanceof GenericArrayType)) { return false; } GenericArrayType ga = (GenericArrayType) a; GenericArrayType gb = (GenericArrayType) b; return equals(ga.getGenericComponentType(), gb.getGenericComponentType()); } else if (a instanceof WildcardType) { if (!(b instanceof WildcardType)) { return false; } WildcardType wa = (WildcardType) a; WildcardType wb = (WildcardType) b; return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds()) && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds()); } else if (a instanceof TypeVariable) { if (!(b instanceof TypeVariable)) { return false; } TypeVariable<?> va = (TypeVariable<?>) a; TypeVariable<?> vb = (TypeVariable<?>) b; return va.getGenericDeclaration() == vb.getGenericDeclaration() && va.getName().equals(vb.getName()); } else { return false; } } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) { return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>()); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static WildcardType subtypeOf(Type bound) { Type[] upperBounds; if (bound instanceof WildcardType) { upperBounds = ((WildcardType) bound).getUpperBounds(); } else { upperBounds = new Type[] { bound }; } return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static Type canonicalize(Type type) { if (type instanceof Class) { Class<?> c = (Class<?>) type; return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c; } else if (type instanceof ParameterizedType) { ParameterizedType p = (ParameterizedType) type; return new ParameterizedTypeImpl(p.getOwnerType(), p.getRawType(), p.getActualTypeArguments()); } else if (type instanceof GenericArrayType) { GenericArrayType g = (GenericArrayType) type; return new GenericArrayTypeImpl(g.getGenericComponentType()); } else if (type instanceof WildcardType) { WildcardType w = (WildcardType) type; return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds()); } else { return type; } } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments) { return new ParameterizedTypeImpl(ownerType, rawType, typeArguments); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static WildcardType supertypeOf(Type bound) { Type[] lowerBounds; if (bound instanceof WildcardType) { lowerBounds = ((WildcardType) bound).getLowerBounds(); } else { lowerBounds = new Type[] { bound }; } return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static String typeToString(Type type) { return type instanceof Class ? ((Class<?>) type).getName() : type.toString(); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static GenericArrayType arrayOf(Type componentType) { return new GenericArrayTypeImpl(componentType); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
DefaultDateTypeAdapter extends TypeAdapter<Date> { @Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(SIMPLE_NAME); sb.append('(').append(localFormat.getClass().getSimpleName()).append(')'); return sb.toString(); } DefaultDateTypeAdapter(Class<? extends Date> dateType); DefaultDateTypeAdapter(Class<? extends Date> dateType, String datePattern); DefaultDateTypeAdapter(Class<? extends Date> dateType, int style); DefaultDateTypeAdapter(int dateStyle, int timeStyle); DefaultDateTypeAdapter(Class<? extends Date> dateType, int dateStyle, int timeStyle); DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat); @Override void write(JsonWriter out, Date value); @Override Date read(JsonReader in); @Override String toString(); }
DefaultDateTypeAdapter extends TypeAdapter<Date> { @Override public void write(JsonWriter out, Date value) throws IOException { if (value == null) { out.nullValue(); return; } synchronized (localFormat) { String dateFormatAsString = enUsFormat.format(value); out.value(dateFormatAsString); } } DefaultDateTypeAdapter(Class<? extends Date> dateType); DefaultDateTypeAdapter(Class<? extends Date> dateType, String datePattern); DefaultDateTypeAdapter(Class<? extends Date> dateType, int style); DefaultDateTypeAdapter(int dateStyle, int timeStyle); DefaultDateTypeAdapter(Class<? extends Date> dateType, int dateStyle, int timeStyle); DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat); @Override void write(JsonWriter out, Date value); @Override Date read(JsonReader in); @Override String toString(); }
DefaultDateTypeAdapter extends TypeAdapter<Date> { @Override public Date read(JsonReader in) throws IOException { if (in.peek() == JsonToken.NULL) { in.nextNull(); return null; } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else { throw new AssertionError(); } } DefaultDateTypeAdapter(Class<? extends Date> dateType); DefaultDateTypeAdapter(Class<? extends Date> dateType, String datePattern); DefaultDateTypeAdapter(Class<? extends Date> dateType, int style); DefaultDateTypeAdapter(int dateStyle, int timeStyle); DefaultDateTypeAdapter(Class<? extends Date> dateType, int dateStyle, int timeStyle); DefaultDateTypeAdapter(final Class<? extends Date> dateType, DateFormat enUsFormat, DateFormat localFormat); @Override void write(JsonWriter out, Date value); @Override Date read(JsonReader in); @Override String toString(); }
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Types { public static Class<?> getRawType(Type type) { if (type instanceof Class<?>) { return (Class<?>) type; } else if (type instanceof ParameterizedType) { ParameterizedType parameterizedType = (ParameterizedType) type; Type rawType = parameterizedType.getRawType(); checkArgument(rawType instanceof Class); return (Class<?>) rawType; } else if (type instanceof GenericArrayType) { Type componentType = ((GenericArrayType)type).getGenericComponentType(); return Array.newInstance(getRawType(componentType), 0).getClass(); } else if (type instanceof TypeVariable) { return Object.class; } else if (type instanceof WildcardType) { return getRawType(((WildcardType) type).getUpperBounds()[0]); } else { String className = type == null ? "null" : type.getClass().getName(); throw new IllegalArgumentException("Expected a Class, ParameterizedType, or " + "GenericArrayType, but <" + type + "> is of type " + className); } } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) { if (context == Properties.class) { return new Type[] { String.class, String.class }; } Type mapType = getSupertype(context, contextRawType, Map.class); if (mapType instanceof ParameterizedType) { ParameterizedType mapParameterizedType = (ParameterizedType) mapType; return mapParameterizedType.getActualTypeArguments(); } return new Type[] { Object.class, Object.class }; } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static Type getCollectionElementType(Type context, Class<?> contextRawType) { Type collectionType = getSupertype(context, contextRawType, Collection.class); if (collectionType instanceof WildcardType) { collectionType = ((WildcardType)collectionType).getUpperBounds()[0]; } if (collectionType instanceof ParameterizedType) { return ((ParameterizedType) collectionType).getActualTypeArguments()[0]; } return Object.class; } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static Type getArrayComponentType(Type array) { return array instanceof GenericArrayType ? ((GenericArrayType) array).getGenericComponentType() : ((Class<?>) array).getComponentType(); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static boolean equals(Type a, Type b) { if (a == b) { return true; } else if (a instanceof Class) { return a.equals(b); } else if (a instanceof ParameterizedType) { if (!(b instanceof ParameterizedType)) { return false; } ParameterizedType pa = (ParameterizedType) a; ParameterizedType pb = (ParameterizedType) b; return equal(pa.getOwnerType(), pb.getOwnerType()) && pa.getRawType().equals(pb.getRawType()) && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments()); } else if (a instanceof GenericArrayType) { if (!(b instanceof GenericArrayType)) { return false; } GenericArrayType ga = (GenericArrayType) a; GenericArrayType gb = (GenericArrayType) b; return equals(ga.getGenericComponentType(), gb.getGenericComponentType()); } else if (a instanceof WildcardType) { if (!(b instanceof WildcardType)) { return false; } WildcardType wa = (WildcardType) a; WildcardType wb = (WildcardType) b; return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds()) && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds()); } else if (a instanceof TypeVariable) { if (!(b instanceof TypeVariable)) { return false; } TypeVariable<?> va = (TypeVariable<?>) a; TypeVariable<?> vb = (TypeVariable<?>) b; return va.getGenericDeclaration() == vb.getGenericDeclaration() && va.getName().equals(vb.getName()); } else { return false; } } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) { return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>()); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static WildcardType subtypeOf(Type bound) { Type[] upperBounds; if (bound instanceof WildcardType) { upperBounds = ((WildcardType) bound).getUpperBounds(); } else { upperBounds = new Type[] { bound }; } return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static Type canonicalize(Type type) { if (type instanceof Class) { Class<?> c = (Class<?>) type; return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c; } else if (type instanceof ParameterizedType) { ParameterizedType p = (ParameterizedType) type; return new ParameterizedTypeImpl(p.getOwnerType(), p.getRawType(), p.getActualTypeArguments()); } else if (type instanceof GenericArrayType) { GenericArrayType g = (GenericArrayType) type; return new GenericArrayTypeImpl(g.getGenericComponentType()); } else if (type instanceof WildcardType) { WildcardType w = (WildcardType) type; return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds()); } else { return type; } } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments) { return new ParameterizedTypeImpl(ownerType, rawType, typeArguments); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static WildcardType supertypeOf(Type bound) { Type[] lowerBounds; if (bound instanceof WildcardType) { lowerBounds = ((WildcardType) bound).getLowerBounds(); } else { lowerBounds = new Type[] { bound }; } return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static String typeToString(Type type) { return type instanceof Class ? ((Class<?>) type).getName() : type.toString(); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }
Types { public static GenericArrayType arrayOf(Type componentType) { return new GenericArrayTypeImpl(componentType); } static ParameterizedType newParameterizedTypeWithOwner( Type ownerType, Type rawType, Type... typeArguments); static GenericArrayType arrayOf(Type componentType); static WildcardType subtypeOf(Type bound); static WildcardType supertypeOf(Type bound); static Type canonicalize(Type type); static Class<?> getRawType(Type type); static boolean equals(Type a, Type b); static String typeToString(Type type); static Type getArrayComponentType(Type array); static Type getCollectionElementType(Type context, Class<?> contextRawType); static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType); static Type resolve(Type context, Class<?> contextRawType, Type toResolve); }