ExtendedBufferedReader extends BufferedReader { @Override public String readLine() throws IOException { String line = super.readLine(); if (line != null) { if (line.length() > 0) { lastChar = line.charAt(line.length() - 1); } lineCounter++; } else { lastChar = END_OF_STREAM; } return line; } ExtendedBufferedReader(Reader r); @Override int read(); @Override int read(char[] buf, int offset, int length); @Override String readLine(); }
ExtendedBufferedReader extends BufferedReader { @Override public int read() throws IOException { int current = super.read(); if (current == '\r' || (current == '\n' && lastChar != '\r')) { lineCounter++; } lastChar = current; return lastChar; } ExtendedBufferedReader(Reader r); @Override int read(); @Override int read(char[] buf, int offset, int length); @Override String readLine(); }
ExtendedBufferedReader extends BufferedReader { @Override public int read(char[] buf, int offset, int length) throws IOException { if (length == 0) { return 0; } int len = super.read(buf, offset, length); if (len > 0) { for (int i = offset; i < offset + len; i++) { char ch = buf[i]; if (ch == '\n') { if ('\r' != (i > 0 ? buf[i-1]: lastChar)) { lineCounter++; } } else if (ch == '\r') { lineCounter++; } } lastChar = buf[offset + len - 1]; } else if (len == -1) { lastChar = END_OF_STREAM; } return len; } ExtendedBufferedReader(Reader r); @Override int read(); @Override int read(char[] buf, int offset, int length); @Override String readLine(); }
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CSVRecord implements Serializable, Iterable<String> { public Iterator<String> iterator() { return Arrays.asList(values).iterator(); } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final int i); String get(final String name); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); String getComment(); long getRecordNumber(); int size(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { @Override public String toString() { return Arrays.toString(values); } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final int i); String get(final String name); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); String getComment(); long getRecordNumber(); int size(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public int size() { return values.length; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final int i); String get(final String name); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); String getComment(); long getRecordNumber(); int size(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public String getComment() { return comment; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final int i); String get(final String name); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); String getComment(); long getRecordNumber(); int size(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public boolean isConsistent() { return mapping == null ? true : mapping.size() == values.length; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final int i); String get(final String name); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); String getComment(); long getRecordNumber(); int size(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public boolean isSet(final String name) { return isMapped(name) && mapping.get(name).intValue() < values.length; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final int i); String get(final String name); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); String getComment(); long getRecordNumber(); int size(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public String get(final int i) { return values[i]; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final int i); String get(final String name); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); String getComment(); long getRecordNumber(); int size(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public boolean isMapped(final String name) { return mapping != null ? mapping.containsKey(name) : false; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final int i); String get(final String name); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); String getComment(); long getRecordNumber(); int size(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public long getRecordNumber() { return recordNumber; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final int i); String get(final String name); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); String getComment(); long getRecordNumber(); int size(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public String get(final String name) { if (mapping == null) { throw new IllegalStateException( "No header mapping was specified, the record values can't be accessed by name"); } final Integer index = mapping.get(name); try { return index != null ? values[index.intValue()] : null; } catch (ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException( String.format( "Index for header '%s' is %d but CSVRecord only has %d values!", name, index.intValue(), values.length)); } } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final int i); String get(final String name); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); String getComment(); long getRecordNumber(); int size(); @Override String toString(); }
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CSVParser implements Iterable<CSVRecord>, Closeable { public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(File file, final CSVFormat format); static CSVParser parse(String string, final CSVFormat format); static CSVParser parse(URL url, Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public Iterator<CSVRecord> iterator() { return new Iterator<CSVRecord>() { private CSVRecord current; private CSVRecord getNextRecord() { try { return CSVParser.this.nextRecord(); } catch (final IOException e) { throw new RuntimeException(e); } } public boolean hasNext() { if (CSVParser.this.isClosed()) { return false; } if (this.current == null) { this.current = this.getNextRecord(); } return this.current != null; } public CSVRecord next() { if (CSVParser.this.isClosed()) { throw new NoSuchElementException("CSVParser has been closed"); } CSVRecord next = this.current; this.current = null; if (next == null) { next = this.getNextRecord(); if (next == null) { throw new NoSuchElementException("No more CSV records available"); } } return next; } public void remove() { throw new UnsupportedOperationException(); } }; } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(File file, final CSVFormat format); static CSVParser parse(String string, final CSVFormat format); static CSVParser parse(URL url, Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public boolean isClosed() { return this.lexer.isClosed(); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(File file, final CSVFormat format); static CSVParser parse(String string, final CSVFormat format); static CSVParser parse(URL url, Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public long getRecordNumber() { return this.recordNumber; } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(File file, final CSVFormat format); static CSVParser parse(String string, final CSVFormat format); static CSVParser parse(URL url, Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(URL url, Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(url, "url"); Assertions.notNull(charset, "charset"); Assertions.notNull(format, "format"); return new CSVParser(new InputStreamReader(url.openStream(), charset == null ? Charset.forName("UTF-8") : charset), format); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(File file, final CSVFormat format); static CSVParser parse(String string, final CSVFormat format); static CSVParser parse(URL url, Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public long getCurrentLineNumber() { return this.lexer.getCurrentLineNumber(); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(File file, final CSVFormat format); static CSVParser parse(String string, final CSVFormat format); static CSVParser parse(URL url, Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(File file, final CSVFormat format) throws IOException { Assertions.notNull(file, "file"); Assertions.notNull(format, "format"); return new CSVParser(new FileReader(file), format); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(File file, final CSVFormat format); static CSVParser parse(String string, final CSVFormat format); static CSVParser parse(URL url, Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public void close() throws IOException { if (this.lexer != null) { this.lexer.close(); } } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(File file, final CSVFormat format); static CSVParser parse(String string, final CSVFormat format); static CSVParser parse(URL url, Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public List<CSVRecord> getRecords() throws IOException { final List<CSVRecord> records = new ArrayList<CSVRecord>(); CSVRecord rec; while ((rec = this.nextRecord()) != null) { records.add(rec); } return records; } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(File file, final CSVFormat format); static CSVParser parse(String string, final CSVFormat format); static CSVParser parse(URL url, Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(String string, final CSVFormat format) throws IOException { Assertions.notNull(string, "string"); Assertions.notNull(format, "format"); return new CSVParser(new StringReader(string), format); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(File file, final CSVFormat format); static CSVParser parse(String string, final CSVFormat format); static CSVParser parse(URL url, Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); Iterator<CSVRecord> iterator(); }
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CSVPrinter implements Flushable, Closeable { public void printRecord(final Iterable<?> values) throws IOException { for (final Object value : values) { print(value); } println(); } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public Appendable getOut() { return this.out; } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public void printRecords(final ResultSet resultSet) throws SQLException, IOException { final int columnCount = resultSet.getMetaData().getColumnCount(); while (resultSet.next()) { for (int i = 1; i <= columnCount; i++) { print(resultSet.getString(i)); } println(); } } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public void printRecords(final Object[] values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public void printRecord(final Object... values) throws IOException { for (final Object value : values) { print(value); } println(); } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public void print(final Object value) throws IOException { String strValue; if (value == null) { final String nullString = format.getNullString(); strValue = nullString == null ? Constants.EMPTY : nullString; } else { strValue = value.toString(); } this.print(value, strValue, 0, strValue.length()); } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public void println() throws IOException { final String recordSeparator = format.getRecordSeparator(); if (recordSeparator != null) { out.append(recordSeparator); } newRecord = true; } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public void close() throws IOException { if (out instanceof Closeable) { ((Closeable) out).close(); } } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public void printComment(final String comment) throws IOException { if (!format.isCommentingEnabled()) { return; } if (!newRecord) { println(); } out.append(format.getCommentStart().charValue()); out.append(SP); for (int i = 0; i < comment.length(); i++) { final char c = comment.charAt(i); switch (c) { case CR: if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) { i++; } case LF: println(); out.append(format.getCommentStart().charValue()); out.append(SP); break; default: out.append(c); break; } } println(); } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public void printRecords(final Iterable<?> values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public void flush() throws IOException { if (out instanceof Flushable) { ((Flushable) out).flush(); } } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CSVRecord implements Serializable, Iterable<String> { public boolean isConsistent() { return mapping == null ? true : mapping.size() == values.length; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public Map<String, String> toMap() { return putIn(new HashMap<String, String>(values.length)); } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public int size() { return values.length; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public Iterator<String> iterator() { return toList().iterator(); } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public boolean isMapped(final String name) { return mapping != null ? mapping.containsKey(name) : false; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { @Override public String toString() { return Arrays.toString(values); } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public String get(final String name) { if (mapping == null) { throw new IllegalStateException( "No header mapping was specified, the record values can't be accessed by name"); } final Integer index = mapping.get(name); if (index == null) { throw new IllegalArgumentException(String.format("Mapping for %s not found, expected one of %s", name, mapping.keySet())); } try { return values[index.intValue()]; } catch (final ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException(String.format( "Index for header '%s' is %d but CSVRecord only has %d values!", name, index, Integer.valueOf(values.length))); } } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public long getRecordNumber() { return recordNumber; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public String get(final Enum<?> e) { return get(e.toString()); } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public String getComment() { return comment; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public boolean isSet(final String name) { return isMapped(name) && mapping.get(name).intValue() < values.length; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public String get(final int i) { return values[i]; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CSVParser implements Iterable<CSVRecord>, Closeable { public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public Iterator<CSVRecord> iterator() { return new Iterator<CSVRecord>() { private CSVRecord current; private CSVRecord getNextRecord() { try { return CSVParser.this.nextRecord(); } catch (final IOException e) { throw new RuntimeException(e); } } public boolean hasNext() { if (CSVParser.this.isClosed()) { return false; } if (this.current == null) { this.current = this.getNextRecord(); } return this.current != null; } public CSVRecord next() { if (CSVParser.this.isClosed()) { throw new NoSuchElementException("CSVParser has been closed"); } CSVRecord next = this.current; this.current = null; if (next == null) { next = this.getNextRecord(); if (next == null) { throw new NoSuchElementException("No more CSV records available"); } } return next; } public void remove() { throw new UnsupportedOperationException(); } }; } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public boolean isClosed() { return this.lexer.isClosed(); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public <T extends Collection<CSVRecord>> T getRecords(T records) throws IOException { CSVRecord rec; while ((rec = this.nextRecord()) != null) { records.add(rec); } return records; } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public long getRecordNumber() { return this.recordNumber; } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(url, "url"); Assertions.notNull(charset, "charset"); Assertions.notNull(format, "format"); return new CSVParser(new InputStreamReader(url.openStream(), charset), format); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public long getCurrentLineNumber() { return this.lexer.getCurrentLineNumber(); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final File file, final CSVFormat format) throws IOException { Assertions.notNull(file, "file"); Assertions.notNull(format, "format"); return new CSVParser(new FileReader(file), format); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public void close() throws IOException { if (this.lexer != null) { this.lexer.close(); } } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public List<CSVRecord> getRecords() throws IOException { return getRecords(new ArrayList<CSVRecord>()); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final String string, final CSVFormat format) throws IOException { Assertions.notNull(string, "string"); Assertions.notNull(format, "format"); return new CSVParser(new StringReader(string), format); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CSVFormat implements Serializable { public CSVFormat withCommentStart(final char commentStart) { return withCommentStart(Character.valueOf(commentStart)); } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public Character getEscape() { return escape; } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean isNullHandling() { return nullString != null; } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public Character getQuoteChar() { return quoteChar; } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public String getNullString() { return nullString; } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public Quote getQuotePolicy() { return quotePolicy; } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withQuotePolicy(final Quote quotePolicy) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException("The delimiter cannot be a line break"); } return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean isQuoting() { return quoteChar != null; } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean isEscaping() { return escape != null; } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withQuoteChar(final char quoteChar) { return withQuoteChar(Character.valueOf(quoteChar)); } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public String format(final Object... values) { final StringWriter out = new StringWriter(); try { new CSVPrinter(out, this).printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withHeader(final String... header) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false); } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public Character getCommentStart() { return commentStart; } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Delimiter=<").append(delimiter).append('>'); if (isEscaping()) { sb.append(' '); sb.append("Escape=<").append(escape).append('>'); } if (isQuoting()) { sb.append(' '); sb.append("QuoteChar=<").append(quoteChar).append('>'); } if (isCommentingEnabled()) { sb.append(' '); sb.append("CommentStart=<").append(commentStart).append('>'); } if (isNullHandling()) { sb.append(' '); sb.append("NullString=<").append(nullString).append('>'); } if(recordSeparator != null) { sb.append(' '); sb.append("RecordSeparator=<").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append(" EmptyLines:ignored"); } if (getIgnoreSurroundingSpaces()) { sb.append(" SurroundingSpaces:ignored"); } sb.append(" SkipHeaderRecord:").append(skipHeaderRecord); if (header != null) { sb.append(' '); sb.append("Header:").append(Arrays.toString(header)); } return sb.toString(); } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withCommentStart(final Character commentStart) { if (isLineBreak(commentStart)) { throw new IllegalArgumentException("The comment start character cannot be a line break"); } return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withQuoteChar(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException("The quoteChar cannot be a line break"); } return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException("The escape character cannot be a line break"); } return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord); } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean isCommentingEnabled() { return commentStart != null; } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quotePolicy != other.quotePolicy) { return false; } if (quoteChar == null) { if (other.quoteChar != null) { return false; } } else if (!quoteChar.equals(other.quoteChar)) { return false; } if (commentStart == null) { if (other.commentStart != null) { return false; } } else if (!commentStart.equals(other.commentStart)) { return false; } if (escape == null) { if (other.escape != null) { return false; } } else if (!escape.equals(other.escape)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quotePolicy == null) ? 0 : quotePolicy.hashCode()); result = prime * result + ((quoteChar == null) ? 0 : quoteChar.hashCode()); result = prime * result + ((commentStart == null) ? 0 : commentStart.hashCode()); result = prime * result + ((escape == null) ? 0 : escape.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentStart(); char getDelimiter(); Character getEscape(); String[] getHeader(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteChar(); Quote getQuotePolicy(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentingEnabled(); boolean isEscaping(); boolean isNullHandling(); boolean isQuoting(); CSVParser parse(final Reader in); @Override String toString(); CSVFormat withCommentStart(final char commentStart); CSVFormat withCommentStart(final Character commentStart); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuoteChar(final char quoteChar); CSVFormat withQuoteChar(final Character quoteChar); CSVFormat withQuotePolicy(final Quote quotePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CSVRecord implements Serializable, Iterable<String> { public boolean isConsistent() { return mapping == null || mapping.size() == values.length; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public Map<String, String> toMap() { return putIn(new HashMap<String, String>(values.length)); } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public int size() { return values.length; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public Iterator<String> iterator() { return toList().iterator(); } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public boolean isMapped(final String name) { return mapping != null && mapping.containsKey(name); } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { @Override public String toString() { return Arrays.toString(values); } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public String get(final String name) { if (mapping == null) { throw new IllegalStateException( "No header mapping was specified, the record values can't be accessed by name"); } final Integer index = mapping.get(name); if (index == null) { throw new IllegalArgumentException(String.format("Mapping for %s not found, expected one of %s", name, mapping.keySet())); } try { return values[index.intValue()]; } catch (final ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException(String.format( "Index for header '%s' is %d but CSVRecord only has %d values!", name, index, Integer.valueOf(values.length))); } } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public long getRecordNumber() { return recordNumber; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public String get(final Enum<?> e) { return get(e.toString()); } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public String getComment() { return comment; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public boolean isSet(final String name) { return isMapped(name) && mapping.get(name).intValue() < values.length; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
CSVRecord implements Serializable, Iterable<String> { public String get(final int i) { return values[i]; } CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber); String get(final Enum<?> e); String get(final int i); String get(final String name); String getComment(); long getRecordNumber(); boolean isConsistent(); boolean isMapped(final String name); boolean isSet(final String name); Iterator<String> iterator(); int size(); Map<String, String> toMap(); @Override String toString(); }
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CSVPrinter implements Flushable, Closeable { public void printRecord(final Iterable<?> values) throws IOException { for (final Object value : values) { print(value); } println(); } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public Appendable getOut() { return this.out; } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public void printRecords(final ResultSet resultSet) throws SQLException, IOException { final int columnCount = resultSet.getMetaData().getColumnCount(); while (resultSet.next()) { for (int i = 1; i <= columnCount; i++) { print(resultSet.getString(i)); } println(); } } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public void printRecords(final Object[] values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public void printRecord(final Object... values) throws IOException { for (final Object value : values) { print(value); } println(); } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public void print(final Object value) throws IOException { String strValue; if (value == null) { final String nullString = format.getNullString(); strValue = nullString == null ? Constants.EMPTY : nullString; } else { strValue = value.toString(); } this.print(value, strValue, 0, strValue.length()); } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public void println() throws IOException { final String recordSeparator = format.getRecordSeparator(); if (recordSeparator != null) { out.append(recordSeparator); } newRecord = true; } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public void close() throws IOException { if (out instanceof Closeable) { ((Closeable) out).close(); } } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public void printComment(final String comment) throws IOException { if (!format.isCommentingEnabled()) { return; } if (!newRecord) { println(); } out.append(format.getCommentStart().charValue()); out.append(SP); for (int i = 0; i < comment.length(); i++) { final char c = comment.charAt(i); switch (c) { case CR: if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) { i++; } case LF: println(); out.append(format.getCommentStart().charValue()); out.append(SP); break; default: out.append(c); break; } } println(); } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public void printRecords(final Iterable<?> values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
CSVPrinter implements Flushable, Closeable { public void flush() throws IOException { if (out instanceof Flushable) { ((Flushable) out).flush(); } } CSVPrinter(final Appendable out, final CSVFormat format); void close(); void flush(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object[] values); void printRecords(final ResultSet resultSet); Appendable getOut(); }
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CSVParser implements Iterable<CSVRecord>, Closeable { public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final Charset charset, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(final T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public Iterator<CSVRecord> iterator() { return new Iterator<CSVRecord>() { private CSVRecord current; private CSVRecord getNextRecord() { try { return CSVParser.this.nextRecord(); } catch (final IOException e) { throw new RuntimeException(e); } } public boolean hasNext() { if (CSVParser.this.isClosed()) { return false; } if (this.current == null) { this.current = this.getNextRecord(); } return this.current != null; } public CSVRecord next() { if (CSVParser.this.isClosed()) { throw new NoSuchElementException("CSVParser has been closed"); } CSVRecord next = this.current; this.current = null; if (next == null) { next = this.getNextRecord(); if (next == null) { throw new NoSuchElementException("No more CSV records available"); } } return next; } public void remove() { throw new UnsupportedOperationException(); } }; } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final Charset charset, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(final T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public boolean isClosed() { return this.lexer.isClosed(); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final Charset charset, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(final T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public <T extends Collection<CSVRecord>> T getRecords(final T records) throws IOException { CSVRecord rec; while ((rec = this.nextRecord()) != null) { records.add(rec); } return records; } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final Charset charset, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(final T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public long getRecordNumber() { return this.recordNumber; } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final Charset charset, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(final T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(url, "url"); Assertions.notNull(charset, "charset"); Assertions.notNull(format, "format"); return new CSVParser(new InputStreamReader(url.openStream(), charset), format); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final Charset charset, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(final T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public long getCurrentLineNumber() { return this.lexer.getCurrentLineNumber(); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final Charset charset, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(final T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(file, "file"); Assertions.notNull(format, "format"); return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final Charset charset, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(final T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public void close() throws IOException { if (this.lexer != null) { this.lexer.close(); } } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final Charset charset, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(final T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public List<CSVRecord> getRecords() throws IOException { return getRecords(new ArrayList<CSVRecord>()); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final Charset charset, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(final T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final String string, final CSVFormat format) throws IOException { Assertions.notNull(string, "string"); Assertions.notNull(format, "format"); return new CSVParser(new StringReader(string), format); } CSVParser(final Reader reader, final CSVFormat format); static CSVParser parse(final File file, final Charset charset, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); void close(); long getCurrentLineNumber(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); T getRecords(final T records); boolean isClosed(); Iterator<CSVRecord> iterator(); }
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CSVFormat implements Serializable { public CSVPrinter print(final Appendable out) throws IOException { return new CSVPrinter(out, this); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public Character getEscapeCharacter() { return escapeCharacter; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withQuote(final char quoteChar) { return withQuote(Character.valueOf(quoteChar)); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean isEscapeCharacterSet() { return escapeCharacter != null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public String getNullString() { return nullString; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public QuoteMode getQuoteMode() { return quoteMode; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withHeader(final String... header) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public Character getQuoteCharacter() { return quoteCharacter; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) { return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean isQuoteCharacterSet() { return quoteCharacter != null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withCommentMarker(final char commentMarker) { return withCommentMarker(Character.valueOf(commentMarker)); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean isNullStringSet() { return nullString != null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean isCommentMarkerSet() { return commentMarker != null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException("The escape character cannot be a line break"); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public String format(final Object... values) { final StringWriter out = new StringWriter(); try { new CSVPrinter(out, this).printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false, false); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public Character getCommentMarker() { return commentMarker; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean getAllowMissingColumnNames() { return allowMissingColumnNames; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withCommentMarker(final Character commentMarker) { if (isLineBreak(commentMarker)) { throw new IllegalArgumentException("The comment start marker character cannot be a line break"); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Delimiter=<").append(delimiter).append('>'); if (isEscapeCharacterSet()) { sb.append(' '); sb.append("Escape=<").append(escapeCharacter).append('>'); } if (isQuoteCharacterSet()) { sb.append(' '); sb.append("QuoteChar=<").append(quoteCharacter).append('>'); } if (isCommentMarkerSet()) { sb.append(' '); sb.append("CommentStart=<").append(commentMarker).append('>'); } if (isNullStringSet()) { sb.append(' '); sb.append("NullString=<").append(nullString).append('>'); } if(recordSeparator != null) { sb.append(' '); sb.append("RecordSeparator=<").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append(" EmptyLines:ignored"); } if (getIgnoreSurroundingSpaces()) { sb.append(" SurroundingSpaces:ignored"); } sb.append(" SkipHeaderRecord:").append(skipHeaderRecord); if (header != null) { sb.append(' '); sb.append("Header:").append(Arrays.toString(header)); } return sb.toString(); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException("The delimiter cannot be a line break"); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withQuote(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException("The quoteChar cannot be a line break"); } return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, allowMissingColumnNames); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode()); result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode()); result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode()); result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quoteMode != other.quoteMode) { return false; } if (quoteCharacter == null) { if (other.quoteCharacter != null) { return false; } } else if (!quoteCharacter.equals(other.quoteCharacter)) { return false; } if (commentMarker == null) { if (other.commentMarker != null) { return false; } } else if (!commentMarker.equals(other.commentMarker)) { return false; } if (escapeCharacter == null) { if (other.escapeCharacter != null) { return false; } } else if (!escapeCharacter.equals(other.escapeCharacter)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames); static CSVFormat newFormat(final char delimiter); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CSVFormat implements Serializable { public boolean isNullStringSet() { return nullString != null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withQuote(final char quoteChar) { return withQuote(Character.valueOf(quoteChar)); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVPrinter implements Flushable, Closeable { public Appendable getOut() { return this.out; } CSVPrinter(final Appendable out, final CSVFormat format); @Override void close(); @Override void flush(); Appendable getOut(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object... values); void printRecords(final ResultSet resultSet); }
CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException { String[] labels = null; if (metaData != null) { final int columnCount = metaData.getColumnCount(); labels = new String[columnCount]; for (int i = 0; i < columnCount; i++) { labels[i] = metaData.getColumnLabel(i + 1); } } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, labels, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines() { return this.withIgnoreEmptyLines(true); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase() { return this.withIgnoreHeaderCase(true); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVPrinter implements Flushable, Closeable { public void printRecords(final Iterable<?> values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } CSVPrinter(final Appendable out, final CSVFormat format); @Override void close(); @Override void flush(); Appendable getOut(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object... values); void printRecords(final ResultSet resultSet); }
CSVFormat implements Serializable { public boolean getIgnoreHeaderCase() { return ignoreHeaderCase; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) { return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean getAllowMissingColumnNames() { return allowMissingColumnNames; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVPrinter implements Flushable, Closeable { public void print(final Object value) throws IOException { String strValue; if (value == null) { final String nullString = format.getNullString(); strValue = nullString == null ? Constants.EMPTY : nullString; } else { strValue = value.toString(); } this.print(value, strValue, 0, strValue.length()); } CSVPrinter(final Appendable out, final CSVFormat format); @Override void close(); @Override void flush(); Appendable getOut(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object... values); void printRecords(final ResultSet resultSet); }
CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException("The delimiter cannot be a line break"); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public String[] getHeaderComments() { return headerComments != null ? headerComments.clone() : null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public Character getEscapeCharacter() { return escapeCharacter; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord() { return this.withSkipHeaderRecord(true); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames() { return this.withAllowMissingColumnNames(true); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSet resultSet) throws SQLException { return withHeader(resultSet != null ? resultSet.getMetaData() : null); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean isCommentMarkerSet() { return commentMarker != null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces() { return this.withIgnoreSurroundingSpaces(true); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVPrinter implements Flushable, Closeable { public void printComment(final String comment) throws IOException { if (!format.isCommentMarkerSet()) { return; } if (!newRecord) { println(); } out.append(format.getCommentMarker().charValue()); out.append(SP); for (int i = 0; i < comment.length(); i++) { final char c = comment.charAt(i); switch (c) { case CR: if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) { i++; } case LF: println(); out.append(format.getCommentMarker().charValue()); out.append(SP); break; default: out.append(c); break; } } println(); } CSVPrinter(final Appendable out, final CSVFormat format); @Override void close(); @Override void flush(); Appendable getOut(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object... values); void printRecords(final ResultSet resultSet); }
CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVPrinter implements Flushable, Closeable { public void println() throws IOException { final String recordSeparator = format.getRecordSeparator(); if (recordSeparator != null) { out.append(recordSeparator); } newRecord = true; } CSVPrinter(final Appendable out, final CSVFormat format); @Override void close(); @Override void flush(); Appendable getOut(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object... values); void printRecords(final ResultSet resultSet); }
CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode()); result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode()); result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode()); result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreHeaderCase ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withQuote(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException("The quoteChar cannot be a line break"); } return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVPrinter implements Flushable, Closeable { @Override public void flush() throws IOException { if (out instanceof Flushable) { ((Flushable) out).flush(); } } CSVPrinter(final Appendable out, final CSVFormat format); @Override void close(); @Override void flush(); Appendable getOut(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object... values); void printRecords(final ResultSet resultSet); }
CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException("The escape character cannot be a line break"); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withCommentMarker(final Character commentMarker) { if (isLineBreak(commentMarker)) { throw new IllegalArgumentException("The comment start marker character cannot be a line break"); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVPrinter implements Flushable, Closeable { public void printRecord(final Object... values) throws IOException { for (final Object value : values) { print(value); } println(); } CSVPrinter(final Appendable out, final CSVFormat format); @Override void close(); @Override void flush(); Appendable getOut(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object... values); void printRecords(final ResultSet resultSet); }
CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quoteMode != other.quoteMode) { return false; } if (quoteCharacter == null) { if (other.quoteCharacter != null) { return false; } } else if (!quoteCharacter.equals(other.quoteCharacter)) { return false; } if (commentMarker == null) { if (other.commentMarker != null) { return false; } } else if (!commentMarker.equals(other.commentMarker)) { return false; } if (escapeCharacter == null) { if (other.escapeCharacter != null) { return false; } } else if (!escapeCharacter.equals(other.escapeCharacter)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withCommentMarker(final char commentMarker) { return withCommentMarker(Character.valueOf(commentMarker)); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVPrinter implements Flushable, Closeable { public void printRecords(final ResultSet resultSet) throws SQLException, IOException { final int columnCount = resultSet.getMetaData().getColumnCount(); while (resultSet.next()) { for (int i = 1; i <= columnCount; i++) { print(resultSet.getObject(i)); } println(); } } CSVPrinter(final Appendable out, final CSVFormat format); @Override void close(); @Override void flush(); Appendable getOut(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object... values); void printRecords(final ResultSet resultSet); }
CSVFormat implements Serializable { public Character getCommentMarker() { return commentMarker; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public String format(final Object... values) { final StringWriter out = new StringWriter(); try { new CSVPrinter(out, this).printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVPrinter implements Flushable, Closeable { public void printRecords(final Object... values) throws IOException { for (final Object value : values) { if (value instanceof Object[]) { this.printRecord((Object[]) value); } else if (value instanceof Iterable) { this.printRecord((Iterable<?>) value); } else { this.printRecord(value); } } } CSVPrinter(final Appendable out, final CSVFormat format); @Override void close(); @Override void flush(); Appendable getOut(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object... values); void printRecords(final ResultSet resultSet); }
CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public boolean isEscapeCharacterSet() { return escapeCharacter != null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public String getNullString() { return nullString; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVPrinter print(final Appendable out) throws IOException { return new CSVPrinter(out, this); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVPrinter implements Flushable, Closeable { @Override public void close() throws IOException { if (out instanceof Closeable) { ((Closeable) out).close(); } } CSVPrinter(final Appendable out, final CSVFormat format); @Override void close(); @Override void flush(); Appendable getOut(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object... values); void printRecords(final ResultSet resultSet); }
CSVFormat implements Serializable { public boolean isQuoteCharacterSet() { return quoteCharacter != null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withHeader(final String... header) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Delimiter=<").append(delimiter).append('>'); if (isEscapeCharacterSet()) { sb.append(' '); sb.append("Escape=<").append(escapeCharacter).append('>'); } if (isQuoteCharacterSet()) { sb.append(' '); sb.append("QuoteChar=<").append(quoteCharacter).append('>'); } if (isCommentMarkerSet()) { sb.append(' '); sb.append("CommentStart=<").append(commentMarker).append('>'); } if (isNullStringSet()) { sb.append(' '); sb.append("NullString=<").append(nullString).append('>'); } if (recordSeparator != null) { sb.append(' '); sb.append("RecordSeparator=<").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append(" EmptyLines:ignored"); } if (getIgnoreSurroundingSpaces()) { sb.append(" SurroundingSpaces:ignored"); } if (getIgnoreHeaderCase()) { sb.append(" IgnoreHeaderCase:ignored"); } sb.append(" SkipHeaderRecord:").append(skipHeaderRecord); if (headerComments != null) { sb.append(' '); sb.append("HeaderComments:").append(Arrays.toString(headerComments)); } if (header != null) { sb.append(' '); sb.append("Header:").append(Arrays.toString(header)); } return sb.toString(); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public CSVFormat withHeaderComments(final Object... headerComments) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public QuoteMode getQuoteMode() { return quoteMode; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVPrinter implements Flushable, Closeable { public void printRecord(final Iterable<?> values) throws IOException { for (final Object value : values) { print(value); } println(); } CSVPrinter(final Appendable out, final CSVFormat format); @Override void close(); @Override void flush(); Appendable getOut(); void print(final Object value); void printComment(final String comment); void println(); void printRecord(final Iterable<?> values); void printRecord(final Object... values); void printRecords(final Iterable<?> values); void printRecords(final Object... values); void printRecords(final ResultSet resultSet); }
CSVFormat implements Serializable { public static CSVFormat valueOf(final String format) { return CSVFormat.Predefined.valueOf(format).getFormat(); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
CSVFormat implements Serializable { public Character getQuoteCharacter() { return quoteCharacter; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getAllowMissingColumnNames(); boolean getIgnoreEmptyLines(); boolean getIgnoreSurroundingSpaces(); boolean getIgnoreHeaderCase(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @Override String toString(); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withHeader(final String... header); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); static final CSVFormat DEFAULT; static final CSVFormat RFC4180; static final CSVFormat EXCEL; static final CSVFormat TDF; static final CSVFormat MYSQL; }
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CSVFormat implements Serializable { public boolean isCommentMarkerSet() { return commentMarker != null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public Character getCommentMarker() { return commentMarker; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withHeader(final String... header) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withQuote(final char quoteChar) { return withQuote(Character.valueOf(quoteChar)); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSet resultSet) throws SQLException { return withHeader(resultSet != null ? resultSet.getMetaData() : null); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames() { return this.withAllowMissingColumnNames(true); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException("The delimiter cannot be a line break"); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) { String[] header = null; if (headerEnum != null) { final Enum<?>[] enumValues = headerEnum.getEnumConstants(); header = new String[enumValues.length]; for (int i = 0; i < enumValues.length; i++) { header[i] = enumValues[i].name(); } } return withHeader(header); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines() { return this.withIgnoreEmptyLines(true); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public String[] getHeaderComments() { return headerComments != null ? headerComments.clone() : null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withCommentMarker(final Character commentMarker) { if (isLineBreak(commentMarker)) { throw new IllegalArgumentException("The comment start marker character cannot be a line break"); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withQuote(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException("The quoteChar cannot be a line break"); } return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVPrinter print(final Path out, Charset charset) throws IOException { return print(out.toFile(), charset); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withFirstRecordAsHeader() { return withHeader().withSkipHeaderRecord(); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException { String[] labels = null; if (metaData != null) { final int columnCount = metaData.getColumnCount(); labels = new String[columnCount]; for (int i = 0; i < columnCount; i++) { labels[i] = metaData.getColumnLabel(i + 1); } } return withHeader(labels); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean getIgnoreHeaderCase() { return ignoreHeaderCase; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withCommentMarker(final char commentMarker) { return withCommentMarker(Character.valueOf(commentMarker)); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Delimiter=<").append(delimiter).append('>'); if (isEscapeCharacterSet()) { sb.append(' '); sb.append("Escape=<").append(escapeCharacter).append('>'); } if (isQuoteCharacterSet()) { sb.append(' '); sb.append("QuoteChar=<").append(quoteCharacter).append('>'); } if (isCommentMarkerSet()) { sb.append(' '); sb.append("CommentStart=<").append(commentMarker).append('>'); } if (isNullStringSet()) { sb.append(' '); sb.append("NullString=<").append(nullString).append('>'); } if (recordSeparator != null) { sb.append(' '); sb.append("RecordSeparator=<").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append(" EmptyLines:ignored"); } if (getIgnoreSurroundingSpaces()) { sb.append(" SurroundingSpaces:ignored"); } if (getIgnoreHeaderCase()) { sb.append(" IgnoreHeaderCase:ignored"); } sb.append(" SkipHeaderRecord:").append(skipHeaderRecord); if (headerComments != null) { sb.append(' '); sb.append("HeaderComments:").append(Arrays.toString(headerComments)); } if (header != null) { sb.append(' '); sb.append("Header:").append(Arrays.toString(header)); } return sb.toString(); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean getTrim() { return trim; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException("The escape character cannot be a line break"); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) { return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase() { return this.withIgnoreHeaderCase(true); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withTrim() { return withTrim(true); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces() { return this.withIgnoreSurroundingSpaces(true); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean isNullStringSet() { return nullString != null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean getTrailingDelimiter() { return trailingDelimiter; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withHeaderComments(final Object... headerComments) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public void println(final Appendable out) throws IOException { if (getTrailingDelimiter()) { out.append(getDelimiter()); } if (recordSeparator != null) { out.append(recordSeparator); } } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withTrim(final boolean trim) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { @SuppressWarnings("resource") public CSVPrinter print(final File out, Charset charset) throws IOException { return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord() { return this.withSkipHeaderRecord(true); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quoteMode != other.quoteMode) { return false; } if (quoteCharacter == null) { if (other.quoteCharacter != null) { return false; } } else if (!quoteCharacter.equals(other.quoteCharacter)) { return false; } if (commentMarker == null) { if (other.commentMarker != null) { return false; } } else if (!commentMarker.equals(other.commentMarker)) { return false; } if (escapeCharacter == null) { if (other.escapeCharacter != null) { return false; } } else if (!escapeCharacter.equals(other.escapeCharacter)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVPrinter print(final Appendable out) throws IOException { return new CSVPrinter(out, this); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean getAllowMissingColumnNames() { return allowMissingColumnNames; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false, false, false); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public String format(final Object... values) { final StringWriter out = new StringWriter(); try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) { csvPrinter.printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withTrailingDelimiter() { return withTrailingDelimiter(true); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException { CharSequence charSequence; if (value == null) { charSequence = nullString == null ? Constants.EMPTY : nullString; } else { charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString(); } charSequence = getTrim() ? trim(charSequence) : charSequence; this.print(value, charSequence, 0, charSequence.length(), out, newRecord); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public Character getEscapeCharacter() { return escapeCharacter; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode()); result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode()); result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode()); result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreHeaderCase ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public String getNullString() { return nullString; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean isQuoteCharacterSet() { return quoteCharacter != null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean isEscapeCharacterSet() { return escapeCharacter != null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public void printRecord(final Appendable out, final Object... values) throws IOException { for (int i = 0; i < values.length; i++) { print(values[i], out, i == 0); } println(out); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public QuoteMode getQuoteMode() { return quoteMode; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public static CSVFormat valueOf(final String format) { return CSVFormat.Predefined.valueOf(format).getFormat(); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public Character getQuoteCharacter() { return quoteCharacter; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); @SuppressWarnings("resource") CSVPrinter print(final File out, Charset charset); CSVPrinter print(final Path out, Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat RFC4180; static final CSVFormat TDF; }
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CSVFormat implements Serializable { @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + delimiter; result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode()); result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode()); result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode()); result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode()); result = prime * result + ((nullString == null) ? 0 : nullString.hashCode()); result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237); result = prime * result + (ignoreHeaderCase ? 1231 : 1237); result = prime * result + (ignoreEmptyLines ? 1231 : 1237); result = prime * result + (skipHeaderRecord ? 1231 : 1237); result = prime * result + ((recordSeparator == null) ? 0 : recordSeparator.hashCode()); result = prime * result + Arrays.hashCode(header); return result; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public Character getCommentMarker() { return commentMarker; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSet resultSet) throws SQLException { return withHeader(resultSet != null ? resultSet.getMetaData() : null); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withFirstRecordAsHeader() { return withHeader().withSkipHeaderRecord(); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withTrim() { return withTrim(true); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public void printRecord(final Appendable out, final Object... values) throws IOException { for (int i = 0; i < values.length; i++) { print(values[i], out, i == 0); } println(out); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withCommentMarker(final char commentMarker) { return withCommentMarker(Character.valueOf(commentMarker)); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withEscape(final Character escape) { if (isLineBreak(escape)) { throw new IllegalArgumentException("The escape character cannot be a line break"); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean getSkipHeaderRecord() { return skipHeaderRecord; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean getIgnoreEmptyLines() { return ignoreEmptyLines; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final String recordSeparator) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean getIgnoreSurroundingSpaces() { return ignoreSurroundingSpaces; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withHeader(final String... header) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public String[] getHeaderComments() { return headerComments != null ? headerComments.clone() : null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withNullString(final String nullString) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVPrinter printer() throws IOException { return new CSVPrinter(System.out, this); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public String[] getHeader() { return header != null ? header.clone() : null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public char getDelimiter() { return delimiter; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withEscape(final char escape) { return withEscape(Character.valueOf(escape)); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withTrim(final boolean trim) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) { String[] header = null; if (headerEnum != null) { final Enum<?>[] enumValues = headerEnum.getEnumConstants(); header = new String[enumValues.length]; for (int i = 0; i < enumValues.length; i++) { header[i] = enumValues[i].name(); } } return withHeader(header); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean getIgnoreHeaderCase() { return ignoreHeaderCase; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withAllowMissingColumnNames() { return this.withAllowMissingColumnNames(true); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public void println(final Appendable out) throws IOException { if (getTrailingDelimiter()) { out.append(getDelimiter()); } if (recordSeparator != null) { out.append(recordSeparator); } } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean getTrim() { return trim; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withDelimiter(final char delimiter) { if (isLineBreak(delimiter)) { throw new IllegalArgumentException("The delimiter cannot be a line break"); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withAutoFlush(final boolean autoFlush) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withQuote(final char quoteChar) { return withQuote(Character.valueOf(quoteChar)); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withHeaderComments(final Object... headerComments) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withQuote(final Character quoteChar) { if (isLineBreak(quoteChar)) { throw new IllegalArgumentException("The quoteChar cannot be a line break"); } return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withIgnoreEmptyLines() { return this.withIgnoreEmptyLines(true); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withTrailingDelimiter() { return withTrailingDelimiter(true); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase() { return this.withIgnoreHeaderCase(true); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean isEscapeCharacterSet() { return escapeCharacter != null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean getTrailingDelimiter() { return trailingDelimiter; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withHeader(final ResultSetMetaData metaData) throws SQLException { String[] labels = null; if (metaData != null) { final int columnCount = metaData.getColumnCount(); labels = new String[columnCount]; for (int i = 0; i < columnCount; i++) { labels[i] = metaData.getColumnLabel(i + 1); } } return withHeader(labels); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withIgnoreSurroundingSpaces() { return this.withIgnoreSurroundingSpaces(true); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public String getRecordSeparator() { return recordSeparator; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVPrinter print(final Path out, final Charset charset) throws IOException { return print(Files.newBufferedWriter(out, charset)); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withCommentMarker(final Character commentMarker) { if (isLineBreak(commentMarker)) { throw new IllegalArgumentException("The comment start marker character cannot be a line break"); } return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withTrailingDelimiter(final boolean trailingDelimiter) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVPrinter print(final Appendable out) throws IOException { return new CSVPrinter(out, this); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withRecordSeparator(final char recordSeparator) { return withRecordSeparator(String.valueOf(recordSeparator)); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { @Override public boolean equals(final Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final CSVFormat other = (CSVFormat) obj; if (delimiter != other.delimiter) { return false; } if (quoteMode != other.quoteMode) { return false; } if (quoteCharacter == null) { if (other.quoteCharacter != null) { return false; } } else if (!quoteCharacter.equals(other.quoteCharacter)) { return false; } if (commentMarker == null) { if (other.commentMarker != null) { return false; } } else if (!commentMarker.equals(other.commentMarker)) { return false; } if (escapeCharacter == null) { if (other.escapeCharacter != null) { return false; } } else if (!escapeCharacter.equals(other.escapeCharacter)) { return false; } if (nullString == null) { if (other.nullString != null) { return false; } } else if (!nullString.equals(other.nullString)) { return false; } if (!Arrays.equals(header, other.header)) { return false; } if (ignoreSurroundingSpaces != other.ignoreSurroundingSpaces) { return false; } if (ignoreEmptyLines != other.ignoreEmptyLines) { return false; } if (skipHeaderRecord != other.skipHeaderRecord) { return false; } if (recordSeparator == null) { if (other.recordSeparator != null) { return false; } } else if (!recordSeparator.equals(other.recordSeparator)) { return false; } return true; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVParser parse(final Reader in) throws IOException { return new CSVParser(in, this); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean getAllowMissingColumnNames() { return allowMissingColumnNames; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public static CSVFormat newFormat(final char delimiter) { return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, null, false, false, false, false, false, false); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public String format(final Object... values) { final StringWriter out = new StringWriter(); try (final CSVPrinter csvPrinter = new CSVPrinter(out, this)) { csvPrinter.printRecord(values); return out.toString().trim(); } catch (final IOException e) { throw new IllegalStateException(e); } } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withSkipHeaderRecord() { return this.withSkipHeaderRecord(true); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { @SuppressWarnings("resource") public CSVPrinter print(final File out, final Charset charset) throws IOException { return new CSVPrinter(new OutputStreamWriter(new FileOutputStream(out), charset), this); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public Character getEscapeCharacter() { return escapeCharacter; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean getAutoFlush() { return autoFlush; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public String getNullString() { return nullString; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean isNullStringSet() { return nullString != null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase) { return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean isCommentMarkerSet() { return commentMarker != null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public void print(final Object value, final Appendable out, final boolean newRecord) throws IOException { CharSequence charSequence; if (value == null) { if (null == nullString) { charSequence = EMPTY; } else { if (QuoteMode.ALL == quoteMode) { charSequence = quoteCharacter + nullString + quoteCharacter; } else { charSequence = nullString; } } } else { charSequence = value instanceof CharSequence ? (CharSequence) value : value.toString(); } charSequence = getTrim() ? trim(charSequence) : charSequence; this.print(value, charSequence, 0, charSequence.length(), out, newRecord); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public boolean isQuoteCharacterSet() { return quoteCharacter != null; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append("Delimiter=<").append(delimiter).append('>'); if (isEscapeCharacterSet()) { sb.append(' '); sb.append("Escape=<").append(escapeCharacter).append('>'); } if (isQuoteCharacterSet()) { sb.append(' '); sb.append("QuoteChar=<").append(quoteCharacter).append('>'); } if (isCommentMarkerSet()) { sb.append(' '); sb.append("CommentStart=<").append(commentMarker).append('>'); } if (isNullStringSet()) { sb.append(' '); sb.append("NullString=<").append(nullString).append('>'); } if (recordSeparator != null) { sb.append(' '); sb.append("RecordSeparator=<").append(recordSeparator).append('>'); } if (getIgnoreEmptyLines()) { sb.append(" EmptyLines:ignored"); } if (getIgnoreSurroundingSpaces()) { sb.append(" SurroundingSpaces:ignored"); } if (getIgnoreHeaderCase()) { sb.append(" IgnoreHeaderCase:ignored"); } sb.append(" SkipHeaderRecord:").append(skipHeaderRecord); if (headerComments != null) { sb.append(' '); sb.append("HeaderComments:").append(Arrays.toString(headerComments)); } if (header != null) { sb.append(' '); sb.append("Header:").append(Arrays.toString(header)); } return sb.toString(); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public QuoteMode getQuoteMode() { return quoteMode; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) { return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter, ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, headerComments, header, skipHeaderRecord, allowMissingColumnNames, ignoreHeaderCase, trim, trailingDelimiter, autoFlush); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public static CSVFormat valueOf(final String format) { return CSVFormat.Predefined.valueOf(format).getFormat(); } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
CSVFormat implements Serializable { public Character getQuoteCharacter() { return quoteCharacter; } private CSVFormat(final char delimiter, final Character quoteChar, final QuoteMode quoteMode, final Character commentStart, final Character escape, final boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String recordSeparator, final String nullString, final Object[] headerComments, final String[] header, final boolean skipHeaderRecord, final boolean allowMissingColumnNames, final boolean ignoreHeaderCase, final boolean trim, final boolean trailingDelimiter, final boolean autoFlush); static CSVFormat newFormat(final char delimiter); static CSVFormat valueOf(final String format); @Override boolean equals(final Object obj); String format(final Object... values); boolean getAllowMissingColumnNames(); Character getCommentMarker(); char getDelimiter(); Character getEscapeCharacter(); String[] getHeader(); String[] getHeaderComments(); boolean getIgnoreEmptyLines(); boolean getIgnoreHeaderCase(); boolean getIgnoreSurroundingSpaces(); String getNullString(); Character getQuoteCharacter(); QuoteMode getQuoteMode(); String getRecordSeparator(); boolean getSkipHeaderRecord(); boolean getTrailingDelimiter(); boolean getTrim(); boolean getAutoFlush(); @Override int hashCode(); boolean isCommentMarkerSet(); boolean isEscapeCharacterSet(); boolean isNullStringSet(); boolean isQuoteCharacterSet(); CSVParser parse(final Reader in); CSVPrinter print(final Appendable out); CSVPrinter printer(); @SuppressWarnings("resource") CSVPrinter print(final File out, final Charset charset); CSVPrinter print(final Path out, final Charset charset); void print(final Object value, final Appendable out, final boolean newRecord); void println(final Appendable out); void printRecord(final Appendable out, final Object... values); @Override String toString(); CSVFormat withAllowMissingColumnNames(); CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames); CSVFormat withCommentMarker(final char commentMarker); CSVFormat withCommentMarker(final Character commentMarker); CSVFormat withDelimiter(final char delimiter); CSVFormat withEscape(final char escape); CSVFormat withEscape(final Character escape); CSVFormat withFirstRecordAsHeader(); CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum); CSVFormat withHeader(final ResultSet resultSet); CSVFormat withHeader(final ResultSetMetaData metaData); CSVFormat withHeader(final String... header); CSVFormat withHeaderComments(final Object... headerComments); CSVFormat withIgnoreEmptyLines(); CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines); CSVFormat withIgnoreHeaderCase(); CSVFormat withIgnoreHeaderCase(final boolean ignoreHeaderCase); CSVFormat withIgnoreSurroundingSpaces(); CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces); CSVFormat withNullString(final String nullString); CSVFormat withQuote(final char quoteChar); CSVFormat withQuote(final Character quoteChar); CSVFormat withQuoteMode(final QuoteMode quoteModePolicy); CSVFormat withRecordSeparator(final char recordSeparator); CSVFormat withRecordSeparator(final String recordSeparator); CSVFormat withSkipHeaderRecord(); CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord); CSVFormat withTrailingDelimiter(); CSVFormat withTrailingDelimiter(final boolean trailingDelimiter); CSVFormat withTrim(); CSVFormat withTrim(final boolean trim); CSVFormat withAutoFlush(final boolean autoFlush); static final CSVFormat DEFAULT; static final CSVFormat EXCEL; static final CSVFormat INFORMIX_UNLOAD; static final CSVFormat INFORMIX_UNLOAD_CSV; static final CSVFormat MYSQL; static final CSVFormat POSTGRESQL_CSV; static final CSVFormat POSTGRESQL_TEXT; static final CSVFormat RFC4180; static final CSVFormat TDF; }
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final URL url, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(url, "url"); Assertions.notNull(charset, "charset"); Assertions.notNull(format, "format"); return new CSVParser(new InputStreamReader(url.openStream(), charset), format); } CSVParser(final Reader reader, final CSVFormat format); @SuppressWarnings("resource") CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber); @SuppressWarnings("resource") static CSVParser parse(final File file, final Charset charset, final CSVFormat format); @SuppressWarnings("resource") static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format); static CSVParser parse(final Path path, final Charset charset, final CSVFormat format); static CSVParser parse(final Reader reader, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); @Override void close(); long getCurrentLineNumber(); String getFirstEndOfLine(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); @Override Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public long getRecordNumber() { return this.recordNumber; } CSVParser(final Reader reader, final CSVFormat format); @SuppressWarnings("resource") CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber); @SuppressWarnings("resource") static CSVParser parse(final File file, final Charset charset, final CSVFormat format); @SuppressWarnings("resource") static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format); static CSVParser parse(final Path path, final Charset charset, final CSVFormat format); static CSVParser parse(final Reader reader, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); @Override void close(); long getCurrentLineNumber(); String getFirstEndOfLine(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); @Override Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public boolean isClosed() { return this.lexer.isClosed(); } CSVParser(final Reader reader, final CSVFormat format); @SuppressWarnings("resource") CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber); @SuppressWarnings("resource") static CSVParser parse(final File file, final Charset charset, final CSVFormat format); @SuppressWarnings("resource") static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format); static CSVParser parse(final Path path, final Charset charset, final CSVFormat format); static CSVParser parse(final Reader reader, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); @Override void close(); long getCurrentLineNumber(); String getFirstEndOfLine(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); @Override Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public Map<String, Integer> getHeaderMap() { return this.headerMap == null ? null : new LinkedHashMap<>(this.headerMap); } CSVParser(final Reader reader, final CSVFormat format); @SuppressWarnings("resource") CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber); @SuppressWarnings("resource") static CSVParser parse(final File file, final Charset charset, final CSVFormat format); @SuppressWarnings("resource") static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format); static CSVParser parse(final Path path, final Charset charset, final CSVFormat format); static CSVParser parse(final Reader reader, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); @Override void close(); long getCurrentLineNumber(); String getFirstEndOfLine(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); @Override Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public String getFirstEndOfLine() { return lexer.getFirstEol(); } CSVParser(final Reader reader, final CSVFormat format); @SuppressWarnings("resource") CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber); @SuppressWarnings("resource") static CSVParser parse(final File file, final Charset charset, final CSVFormat format); @SuppressWarnings("resource") static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format); static CSVParser parse(final Path path, final Charset charset, final CSVFormat format); static CSVParser parse(final Reader reader, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); @Override void close(); long getCurrentLineNumber(); String getFirstEndOfLine(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); @Override Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { @Override public void close() throws IOException { if (this.lexer != null) { this.lexer.close(); } } CSVParser(final Reader reader, final CSVFormat format); @SuppressWarnings("resource") CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber); @SuppressWarnings("resource") static CSVParser parse(final File file, final Charset charset, final CSVFormat format); @SuppressWarnings("resource") static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format); static CSVParser parse(final Path path, final Charset charset, final CSVFormat format); static CSVParser parse(final Reader reader, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); @Override void close(); long getCurrentLineNumber(); String getFirstEndOfLine(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); @Override Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public List<CSVRecord> getRecords() throws IOException { CSVRecord rec; final List<CSVRecord> records = new ArrayList<>(); while ((rec = this.nextRecord()) != null) { records.add(rec); } return records; } CSVParser(final Reader reader, final CSVFormat format); @SuppressWarnings("resource") CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber); @SuppressWarnings("resource") static CSVParser parse(final File file, final Charset charset, final CSVFormat format); @SuppressWarnings("resource") static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format); static CSVParser parse(final Path path, final Charset charset, final CSVFormat format); static CSVParser parse(final Reader reader, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); @Override void close(); long getCurrentLineNumber(); String getFirstEndOfLine(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); @Override Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final Path path, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(path, "path"); Assertions.notNull(format, "format"); return parse(Files.newBufferedReader(path, charset), format); } CSVParser(final Reader reader, final CSVFormat format); @SuppressWarnings("resource") CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber); @SuppressWarnings("resource") static CSVParser parse(final File file, final Charset charset, final CSVFormat format); @SuppressWarnings("resource") static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format); static CSVParser parse(final Path path, final Charset charset, final CSVFormat format); static CSVParser parse(final Reader reader, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); @Override void close(); long getCurrentLineNumber(); String getFirstEndOfLine(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); @Override Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final String string, final CSVFormat format) throws IOException { Assertions.notNull(string, "string"); Assertions.notNull(format, "format"); return new CSVParser(new StringReader(string), format); } CSVParser(final Reader reader, final CSVFormat format); @SuppressWarnings("resource") CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber); @SuppressWarnings("resource") static CSVParser parse(final File file, final Charset charset, final CSVFormat format); @SuppressWarnings("resource") static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format); static CSVParser parse(final Path path, final Charset charset, final CSVFormat format); static CSVParser parse(final Reader reader, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); @Override void close(); long getCurrentLineNumber(); String getFirstEndOfLine(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); @Override Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { @SuppressWarnings("resource") public static CSVParser parse(final File file, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(file, "file"); Assertions.notNull(format, "format"); return new CSVParser(new InputStreamReader(new FileInputStream(file), charset), format); } CSVParser(final Reader reader, final CSVFormat format); @SuppressWarnings("resource") CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber); @SuppressWarnings("resource") static CSVParser parse(final File file, final Charset charset, final CSVFormat format); @SuppressWarnings("resource") static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format); static CSVParser parse(final Path path, final Charset charset, final CSVFormat format); static CSVParser parse(final Reader reader, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); @Override void close(); long getCurrentLineNumber(); String getFirstEndOfLine(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); @Override Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public static CSVParser parse(final Reader reader, final CSVFormat format) throws IOException { return new CSVParser(reader, format); } CSVParser(final Reader reader, final CSVFormat format); @SuppressWarnings("resource") CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber); @SuppressWarnings("resource") static CSVParser parse(final File file, final Charset charset, final CSVFormat format); @SuppressWarnings("resource") static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format); static CSVParser parse(final Path path, final Charset charset, final CSVFormat format); static CSVParser parse(final Reader reader, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); @Override void close(); long getCurrentLineNumber(); String getFirstEndOfLine(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); @Override Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { public long getCurrentLineNumber() { return this.lexer.getCurrentLineNumber(); } CSVParser(final Reader reader, final CSVFormat format); @SuppressWarnings("resource") CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber); @SuppressWarnings("resource") static CSVParser parse(final File file, final Charset charset, final CSVFormat format); @SuppressWarnings("resource") static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format); static CSVParser parse(final Path path, final Charset charset, final CSVFormat format); static CSVParser parse(final Reader reader, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); @Override void close(); long getCurrentLineNumber(); String getFirstEndOfLine(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); @Override Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { @Override public Iterator<CSVRecord> iterator() { return csvRecordIterator; } CSVParser(final Reader reader, final CSVFormat format); @SuppressWarnings("resource") CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber); @SuppressWarnings("resource") static CSVParser parse(final File file, final Charset charset, final CSVFormat format); @SuppressWarnings("resource") static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format); static CSVParser parse(final Path path, final Charset charset, final CSVFormat format); static CSVParser parse(final Reader reader, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); @Override void close(); long getCurrentLineNumber(); String getFirstEndOfLine(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); @Override Iterator<CSVRecord> iterator(); }
CSVParser implements Iterable<CSVRecord>, Closeable { @SuppressWarnings("resource") public static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format) throws IOException { Assertions.notNull(inputStream, "inputStream"); Assertions.notNull(format, "format"); return parse(new InputStreamReader(inputStream, charset), format); } CSVParser(final Reader reader, final CSVFormat format); @SuppressWarnings("resource") CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber); @SuppressWarnings("resource") static CSVParser parse(final File file, final Charset charset, final CSVFormat format); @SuppressWarnings("resource") static CSVParser parse(final InputStream inputStream, final Charset charset, final CSVFormat format); static CSVParser parse(final Path path, final Charset charset, final CSVFormat format); static CSVParser parse(final Reader reader, final CSVFormat format); static CSVParser parse(final String string, final CSVFormat format); static CSVParser parse(final URL url, final Charset charset, final CSVFormat format); @Override void close(); long getCurrentLineNumber(); String getFirstEndOfLine(); Map<String, Integer> getHeaderMap(); long getRecordNumber(); List<CSVRecord> getRecords(); boolean isClosed(); @Override Iterator<CSVRecord> iterator(); }